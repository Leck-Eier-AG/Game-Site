---
phase: 04-additional-games
plan: 03
type: tdd
wave: 2
depends_on: [04-01]
files_modified:
  - src/lib/game/blackjack/state-machine.ts
  - src/lib/game/blackjack/engine-wrapper.ts
  - src/lib/game/blackjack/__tests__/state-machine.test.ts
autonomous: true

must_haves:
  truths:
    - "Blackjack state machine handles full round lifecycle: betting -> dealing -> player actions -> dealer actions -> settlement"
    - "All player actions work: hit, stand, double down, split, insurance, surrender"
    - "6-deck shoe reshuffled every round using CSPRNG"
    - "Blackjack pays 3:2"
    - "Solo mode supports up to 3 hands per player"
    - "Multiplayer mode has each player playing independently against dealer"
  artifacts:
    - path: "src/lib/game/blackjack/state-machine.ts"
      provides: "Blackjack game state machine"
      exports: ["createBlackjackState", "applyBlackjackAction", "BlackjackGameState", "BlackjackAction"]
    - path: "src/lib/game/blackjack/engine-wrapper.ts"
      provides: "Wrapper around engine-blackjack with project conventions"
      exports: ["createBlackjackEngine", "getAvailableActions"]
    - path: "src/lib/game/blackjack/__tests__/state-machine.test.ts"
      provides: "Comprehensive test suite for blackjack state machine"
  key_links:
    - from: "src/lib/game/blackjack/engine-wrapper.ts"
      to: "engine-blackjack"
      via: "npm library import"
      pattern: "import.*engine-blackjack"
    - from: "src/lib/game/blackjack/state-machine.ts"
      to: "src/lib/game/cards/deck.ts"
      via: "Deck creation and shuffle"
      pattern: "import.*cards/deck"
---

<objective>
Build the Blackjack game state machine using TDD, wrapping the engine-blackjack library for core game logic while adding multiplayer state management.

Purpose: Blackjack is the simplest of the three new games to implement since engine-blackjack handles complex rule interactions (splits, insurance, surrender timing). This validates the game state machine pattern for card games.
Output: Tested Blackjack state machine with full round lifecycle, multiplayer support, and all player actions.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-additional-games/04-CONTEXT.md
@.planning/phases/04-additional-games/04-RESEARCH.md
@src/lib/game/state-machine.ts
@src/lib/game/cards/types.ts
@src/lib/game/cards/deck.ts
</context>

<feature>
  <name>Blackjack State Machine</name>
  <files>
    src/lib/game/blackjack/state-machine.ts
    src/lib/game/blackjack/engine-wrapper.ts
    src/lib/game/blackjack/__tests__/state-machine.test.ts
  </files>
  <behavior>
    State machine phases: 'betting' -> 'dealing' -> 'player_turn' -> 'dealer_turn' -> 'settlement' -> 'round_end'

    Types:
    - BlackjackGameState: { phase, players (BlackjackPlayer[]), dealer (DealerHand), deck (Card[]), roundNumber, settings }
    - BlackjackPlayer: { userId, displayName, hands (PlayerHand[]), currentHandIndex, bet, insurance, isActive, isConnected }
    - PlayerHand: { cards (Card[]), bet, status ('playing' | 'stood' | 'busted' | 'blackjack' | 'surrendered'), isDoubled, isSplit }
    - DealerHand: { cards (Card[]), hidden (boolean - first card face down until dealer turn) }
    - BlackjackAction: { type: 'PLACE_BET' | 'HIT' | 'STAND' | 'DOUBLE' | 'SPLIT' | 'INSURANCE' | 'SURRENDER' | 'PLAYER_DISCONNECT' }

    Core functions:
    - createBlackjackState(players, settings) -> BlackjackGameState (phase: 'betting')
    - applyBlackjackAction(state, action, userId) -> BlackjackGameState | Error

    Engine wrapper:
    - createBlackjackEngine(config) — creates engine-blackjack Game with project config
    - getAvailableActions(hand, dealerUpCard) — returns valid actions for current hand state

    Game flow:
    1. Betting phase: each player places bet (PLACE_BET action with amount)
    2. Deal: shuffle 6-deck shoe (CSPRNG), deal 2 cards to each player + dealer (one face down)
    3. Player turns: each player acts on their hand(s) in order
       - HIT: add card, bust if > 21
       - STAND: end hand
       - DOUBLE: double bet, receive exactly one card, then stand
       - SPLIT: if pair, split into two hands (each gets one card)
       - INSURANCE: if dealer shows Ace, side bet at 2:1
       - SURRENDER: forfeit half bet, end hand
    4. Dealer turn: reveal hidden card, hit until 17+ (stand on soft 17 — Claude's discretion: choosing stand on soft 17)
    5. Settlement: compare each player hand vs dealer, pay out:
       - Blackjack: 3:2
       - Win: 1:1
       - Push: return bet
       - Lose: lose bet
       - Insurance win: 2:1 (if dealer has blackjack)
    6. Round end: ready for next round

    Test cases:
    - Create initial state with 1-7 players
    - Place bets -> transitions to dealing
    - Deal cards -> each player gets 2 cards, dealer gets 2 (one hidden)
    - HIT -> adds card, busts if > 21
    - STAND -> moves to next hand/player
    - DOUBLE -> doubles bet, one card, auto-stand
    - SPLIT pair -> creates two hands
    - Insurance when dealer shows Ace
    - Surrender -> half bet returned
    - Dealer hits on 16, stands on 17
    - Blackjack (Ace + 10-value) pays 3:2
    - Push returns bet
    - All players busted -> dealer doesn't need to play
    - Solo mode with up to 3 starting hands
    - Player disconnect -> auto-stand on remaining hands
    - Error on invalid action (wrong phase, wrong player, etc.)
  </behavior>
  <implementation>
    1. Create engine-wrapper.ts first — thin wrapper around engine-blackjack for game config
    2. Build state-machine.ts following existing Kniffel pattern:
       - Pure functions (state + action -> new state or Error)
       - No side effects (deck passed in state, shuffled externally by server)
       - Return Error objects, don't throw
    3. Use engine-blackjack for hand value calculation and available action determination
    4. Custom multiplayer orchestration on top (engine-blackjack is single-player)
    5. Hand value calculation: Ace = 1 or 11 (best for player), face cards = 10
  </implementation>
</feature>

<verification>
- `npm test -- --testPathPattern=blackjack` passes all tests
- State machine handles full round lifecycle
- All 6 player actions work correctly
- Error cases return Error objects (not throw)
</verification>

<success_criteria>
- 20+ test cases covering all blackjack actions and phases
- Engine wrapper correctly configures engine-blackjack with project rules
- State machine follows same patterns as existing Kniffel state machine
- Pure functions with no side effects
- Multiplayer orchestration works with 1-7 players
</success_criteria>

<output>
After completion, create `.planning/phases/04-additional-games/04-03-SUMMARY.md`
</output>
