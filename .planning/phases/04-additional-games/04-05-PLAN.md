---
phase: 04-additional-games
plan: 05
type: tdd
wave: 2
depends_on: [04-01]
files_modified:
  - src/lib/game/poker/state-machine.ts
  - src/lib/game/poker/hand-evaluator.ts
  - src/lib/game/poker/__tests__/state-machine.test.ts
  - src/lib/game/poker/__tests__/hand-evaluator.test.ts
autonomous: true

must_haves:
  truths:
    - "Poker state machine handles Texas Hold'em phases: blinds -> preflop -> flop -> turn -> river -> showdown"
    - "Hand evaluator correctly ranks all poker hands from high card to royal flush"
    - "Players can fold, check, call, raise, and go all-in"
    - "Blind posting is automatic (small blind, big blind rotate)"
    - "Dealer button rotates clockwise after each hand"
  artifacts:
    - path: "src/lib/game/poker/state-machine.ts"
      provides: "Texas Hold'em state machine"
      exports: ["createPokerState", "applyPokerAction", "PokerGameState", "PokerAction"]
    - path: "src/lib/game/poker/hand-evaluator.ts"
      provides: "Poker hand evaluation wrapper"
      exports: ["evaluateHand", "compareHands", "getHandName", "findBestHand"]
    - path: "src/lib/game/poker/__tests__/state-machine.test.ts"
      provides: "Poker state machine test suite"
    - path: "src/lib/game/poker/__tests__/hand-evaluator.test.ts"
      provides: "Hand evaluator test suite"
  key_links:
    - from: "src/lib/game/poker/hand-evaluator.ts"
      to: "poker-evaluator-ts"
      via: "Hand ranking library"
      pattern: "import.*poker-evaluator"
    - from: "src/lib/game/poker/state-machine.ts"
      to: "src/lib/game/cards/deck.ts"
      via: "Deck for dealing"
      pattern: "import.*cards/deck"
---

<objective>
Build the Texas Hold'em Poker state machine and hand evaluator using TDD. Poker is the most complex game requiring blind management, betting rounds, community cards, and hand evaluation.

Purpose: The poker state machine handles the full Texas Hold'em hand lifecycle. The hand evaluator wraps poker-evaluator-ts for reliable hand ranking. Side pots are handled separately in Plan 04-06.
Output: Tested poker state machine and hand evaluator.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-additional-games/04-CONTEXT.md
@.planning/phases/04-additional-games/04-RESEARCH.md
@src/lib/game/state-machine.ts
@src/lib/game/cards/types.ts
</context>

<feature>
  <name>Poker State Machine and Hand Evaluator</name>
  <files>
    src/lib/game/poker/hand-evaluator.ts
    src/lib/game/poker/__tests__/hand-evaluator.test.ts
    src/lib/game/poker/state-machine.ts
    src/lib/game/poker/__tests__/state-machine.test.ts
  </files>
  <behavior>
    **hand-evaluator.ts:**
    - Wrapper around poker-evaluator-ts library
    - evaluateHand(cards: Card[]): { rank: number; name: string } — evaluate 5-7 card hand
    - compareHands(handA: Card[], handB: Card[]): -1 | 0 | 1 — compare two hands
    - findBestHand(holeCards: Card[], communityCards: Card[]): { rank: number; name: string; cards: Card[] }
    - getHandName(rank: number): string — German hand names:
      'Royal Flush', 'Straight Flush', 'Vierling', 'Full House', 'Flush', 'Straße', 'Drilling', 'Zwei Paare', 'Ein Paar', 'Höchste Karte'
    - Convert Card type (Rank/Suit) to poker-evaluator-ts format for evaluation

    Test cases for hand-evaluator:
    - Royal flush > straight flush > four of a kind > full house > flush > straight > three of a kind > two pair > pair > high card
    - Ace-low straight (A-2-3-4-5, "wheel") is valid
    - Kicker comparison (same pair, different kicker)
    - 7-card best hand selection (5 best out of 7)
    - Tie detection (exact same hand rank)

    **state-machine.ts:**
    - PokerGameState: {
        phase: 'waiting' | 'blinds' | 'preflop' | 'flop' | 'turn' | 'river' | 'showdown' | 'hand_end' | 'game_end',
        players: PokerPlayer[],
        communityCards: Card[],
        deck: Card[],
        pot: number,
        currentBet: number,
        dealerIndex: number,
        activePlayerIndex: number,
        handNumber: number,
        blinds: { small: number; big: number },
        blindEscalation: boolean,
        blindInterval: number,
        lastBlindIncrease: number,
        settings: PokerSettings
      }
    - PokerPlayer: {
        userId: string,
        displayName: string,
        holeCards: Card[],
        chips: number, // In-game chips (from buy-in)
        currentBet: number, // Bet in current round
        totalBetInHand: number, // Total bet in current hand
        isFolded: boolean,
        isAllIn: boolean,
        isConnected: boolean,
        seatIndex: number, // Fixed seat position (0-8)
        isSittingOut: boolean
      }
    - PokerAction:
        | { type: 'POST_BLINDS' } // Auto
        | { type: 'FOLD' }
        | { type: 'CHECK' }
        | { type: 'CALL' }
        | { type: 'RAISE'; amount: number }
        | { type: 'ALL_IN' }
        | { type: 'PLAYER_DISCONNECT'; userId: string }

    Game flow per hand:
    1. Blinds: auto-post small blind and big blind based on dealer position
    2. Deal: 2 hole cards to each active player (shuffled CSPRNG deck passed in)
    3. Preflop betting round: starting left of big blind
    4. Flop: deal 3 community cards, betting round starting left of dealer
    5. Turn: deal 1 community card, betting round
    6. River: deal 1 community card, final betting round
    7. Showdown: evaluate hands, determine winner(s), distribute pot
    8. Hand end: rotate dealer, reset for next hand

    Betting round rules:
    - Action proceeds clockwise from starting position
    - FOLD: player drops out of hand
    - CHECK: only when no bet to match (currentBet === player.currentBet)
    - CALL: match the current bet
    - RAISE: increase the bet (minimum raise = previous raise amount or big blind)
    - ALL_IN: bet all remaining chips
    - Round ends when all active (non-folded, non-all-in) players have acted and bets are equalized

    Functions:
    - createPokerState(players, settings, deck): PokerGameState
    - applyPokerAction(state, action, userId): PokerGameState | Error

    Test cases for state-machine:
    - Create state with 2-9 players, correct seat assignments
    - Blinds posted automatically with correct amounts
    - Hole cards dealt to each player (2 cards each)
    - FOLD removes player from hand
    - CHECK only valid when no outstanding bet
    - CALL matches current bet exactly
    - RAISE increases bet (minimum raise enforcement)
    - ALL_IN bets remaining chips
    - Betting round ends when all bets equalized
    - Flop deals 3 community cards
    - Turn deals 1 community card
    - River deals 1 community card
    - Showdown evaluates hands and determines winner
    - Dealer rotation after each hand
    - Blind escalation (if enabled, increase after interval)
    - Player disconnect -> auto-fold
    - Last player standing wins (all others folded)
    - Heads-up (2 players): dealer posts small blind, other posts big blind
    - Error: wrong player's turn, invalid bet amount, action in wrong phase
  </behavior>
  <implementation>
    1. Build hand-evaluator.ts first with TDD — wrapper around poker-evaluator-ts
    2. Build state-machine.ts with TDD — one phase at a time
    3. Follow existing Kniffel state machine patterns (pure functions, Error return, immutable state)
    4. Deck is passed via state (shuffled externally by server before dealing)
    5. Side pots are NOT in this plan — handled in 04-06 (pot-calculator.ts)
    6. For now, single pot only. Track totalBetInHand per player for pot calculator
  </implementation>
</feature>

<verification>
- `npm test -- --testPathPattern=poker` passes all tests
- Hand evaluator correctly ranks all hand types
- State machine handles complete hand lifecycle
- Betting round logic is correct (equalize, minimum raise)
</verification>

<success_criteria>
- Hand evaluator ranks all 10 hand types correctly
- Kicker comparison works
- State machine handles blinds -> preflop -> flop -> turn -> river -> showdown
- All betting actions work (fold, check, call, raise, all-in)
- Dealer rotation and blind posting correct
- 30+ test cases covering happy paths and error cases
- Pure functions following project conventions
</success_criteria>

<output>
After completion, create `.planning/phases/04-additional-games/04-05-SUMMARY.md`
</output>
