---
phase: 03-virtual-currency-betting
plan: 13
type: execute
wave: 1
depends_on: []
files_modified:
  - server.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Room creator is charged buy-in and has BetEscrow created on room creation"
    - "Rejoining a bet room does not create duplicate BetEscrow records"
    - "Turn timer expiry triggers auto-play without ReferenceError crash"
    - "AFK kick works in both bet and free rooms without silent errors"
    - "bet:afk-acknowledge socket event is handled by the server"
    - "Disconnect handler cleans up escrow properly based on room/game status"
  artifacts:
    - path: "server.js"
      provides: "Escrow on room:create, idempotent room:join, scoping fix, afk-acknowledge handler, disconnect escrow"
      contains: "ESCROW_CREATE_ROOM_CREATE|ESCROW_IDEMPOTENT_JOIN|ESCROW_DISCONNECT_CLEANUP|AFK_ACKNOWLEDGE_HANDLER"
  key_links:
    - from: "server.js room:create handler"
      to: "prisma.betEscrow.create"
      via: "escrow creation after room creation"
      pattern: "ESCROW_CREATE_ROOM_CREATE"
    - from: "server.js room:join handler"
      to: "prisma.betEscrow.findFirst"
      via: "idempotency check before creating escrow"
      pattern: "ESCROW_IDEMPOTENT_JOIN"
    - from: "server.js autoPlay/kickPlayerAFK"
      to: "sendSystemMessage/emitBalanceUpdate"
      via: "functions must be in same scope"
      pattern: "function sendSystemMessage"
---

<objective>
Fix three server-side bugs discovered during UAT round 2: (1) room creator not charged buy-in, (2) turn timer crashes due to JavaScript scoping, (3) disconnect handler missing escrow cleanup.

Purpose: Without these fixes, bet rooms have broken economics (creator plays for free, duplicate transactions for joiners), turn timers silently crash (AFK players never kicked), and disconnecting players leave orphaned escrow records.

Output: Patched server.js with correct escrow lifecycle for all entry/exit paths and working turn timer scoping.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-virtual-currency-betting/03-08-SUMMARY.md
@.planning/phases/03-virtual-currency-betting/03-11-SUMMARY.md

Schema reference (verified): The BetEscrow model has exactly these fields:
  id (String, cuid), roomId (String), userId (String), amount (Int), status (EscrowStatus),
  lockedAt (DateTime?), releasedAt (DateTime?), createdAt (DateTime).
  Unique constraint: @@unique([roomId, userId]).
  There is NO oddsId field. Use the same field structure as room:join (line 783-789):
  { roomId, userId, amount, status: 'PENDING' }
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add escrow creation to room:create handler for bet rooms</name>
  <files>server.js</files>
  <action>
  In the room:create socket handler (~line 675), after the room is successfully created (line 703-706) and BEFORE calling `socket.join(room.id)`, add bet room escrow for the creator.

  Add a `removeRoom` method to RoomManager if it doesn't exist (simple: `this.rooms.delete(roomId)`).

  Then add the escrow block:
  ```javascript
  // After: const room = await Promise.race([...])
  // Before: socket.join(room.id)

  // [ESCROW_CREATE_ROOM_CREATE] - Creator escrow for bet rooms
  if (settings.isBetRoom) {
    const wallet = await getWalletWithUser(socket.data.userId)
    if (wallet.frozenAt !== null) {
      roomManager.removeRoom(room.id)
      return callback({ success: false, error: 'Wallet is frozen' })
    }
    if (wallet.balance < settings.betAmount) {
      roomManager.removeRoom(room.id)
      return callback({ success: false, error: 'Nicht genug Guthaben fuer den Einsatz' })
    }

    await prisma.$transaction(async (tx) => {
      await tx.wallet.update({
        where: { userId: socket.data.userId },
        data: { balance: { decrement: settings.betAmount } }
      })
      await tx.transaction.create({
        data: {
          type: 'BET_PLACED',
          amount: settings.betAmount,
          userId: socket.data.userId,
          description: `Einsatz: ${room.name}`
        }
      })
      await tx.betEscrow.create({
        data: {
          roomId: room.id,
          userId: socket.data.userId,
          amount: settings.betAmount,
          status: 'PENDING'
        }
      })
    }, { isolationLevel: 'Serializable', maxWait: 5000, timeout: 10000 })

    emitBalanceUpdate(io, socket.data.userId, wallet.balance - settings.betAmount, -settings.betAmount, `Einsatz: ${room.name}`)
  }
  ```

  IMPORTANT: The BetEscrow.create data must use exactly { roomId, userId, amount, status } -- there is NO oddsId field in the schema. Match the existing room:join pattern at line 783-789.

  NOTE: The room:create handler is INSIDE the `app.prepare().then()` closure, so `emitBalanceUpdate` IS accessible here.
  </action>
  <verify>
  1. Grep server.js for `ESCROW_CREATE_ROOM_CREATE` marker -- must return exactly 1 match
  2. Grep server.js for `oddsId` -- must return 0 matches (field does not exist in schema)
  3. Grep server.js for `removeRoom` in RoomManager class -- must exist
  </verify>
  <done>
  - Room creator in bet room has balance debited and BetEscrow PENDING created during room:create
  - BetEscrow.create uses correct schema fields (roomId, userId, amount, status) with no oddsId
  - Failed wallet checks clean up the room via removeRoom before returning error
  </done>
</task>

<task type="auto">
  <name>Task 2: Add idempotency check to room:join escrow and fix disconnect escrow cleanup</name>
  <files>server.js</files>
  <action>
  Two escrow entry/exit path fixes:

  **A) Add idempotency to room:join escrow (~line 738):**
  In the room:join handler, the early return for "already in room" (line 731-734) skips escrow, which is correct for reconnection. But we also need idempotency for the escrow creation itself. Before the `prisma.$transaction` at line 765, add:
  ```javascript
  // [ESCROW_IDEMPOTENT_JOIN] - Check for existing escrow before creating
  const existingEscrow = await prisma.betEscrow.findFirst({
    where: {
      roomId,
      userId: socket.data.userId,
      status: { in: ['PENDING', 'LOCKED'] }
    }
  })
  if (existingEscrow) {
    // Already has active escrow, skip debit and creation
    // Fall through to normal join logic below
  } else {
    // Existing escrow logic: debit balance and create BetEscrow
    await prisma.$transaction(async (tx) => { ... })
    emitBalanceUpdate(...)
  }
  ```
  Restructure the bet room block so the escrow creation is wrapped in the `else` branch.

  **B) Fix disconnect handler to handle escrow (~line 1388):**
  The current disconnect handler calls `removeUserFromAllRooms()` which removes the player from room state but does NOT handle escrow. The room:leave handler (line 833) does handle escrow. The disconnect handler should mirror that logic.

  Replace the disconnect handler:
  ```javascript
  socket.on('disconnect', async () => {
    console.log(`Client disconnected: ${socket.data.userId}`)

    // [ESCROW_DISCONNECT_CLEANUP] - Handle escrow before removing user
    const userRoomIds = roomManager.getUserRooms(socket.data.userId).map(r => r.id)

    for (const roomId of userRoomIds) {
      const room = roomManager.getRoom(roomId)
      if (!room) continue

      if (room.isBetRoom) {
        const wasPlayer = room.players.some(p => p.userId === socket.data.userId)
        if (wasPlayer) {
          try {
            const escrow = await prisma.betEscrow.findFirst({
              where: { roomId, userId: socket.data.userId }
            })
            if (escrow) {
              if (escrow.status === 'PENDING') {
                // Pre-game: refund
                const wallet = await getWalletWithUser(socket.data.userId)
                await prisma.$transaction(async (tx) => {
                  await tx.wallet.update({
                    where: { userId: socket.data.userId },
                    data: { balance: { increment: escrow.amount } }
                  })
                  await tx.transaction.create({
                    data: { type: 'BET_REFUND', amount: escrow.amount, userId: socket.data.userId, description: `Einsatz zurueck: ${room.name}` }
                  })
                  await tx.betEscrow.update({
                    where: { id: escrow.id },
                    data: { status: 'RELEASED', releasedAt: new Date() }
                  })
                }, { isolationLevel: 'Serializable', maxWait: 5000, timeout: 10000 })
                emitBalanceUpdate(io, socket.data.userId, wallet.balance + escrow.amount, escrow.amount, `Einsatz zurueck: ${room.name}`)
              } else if (escrow.status === 'LOCKED') {
                // Mid-game: forfeit
                await prisma.$transaction(async (tx) => {
                  await tx.betEscrow.update({ where: { id: escrow.id }, data: { status: 'FORFEITED' } })
                  await tx.transaction.create({
                    data: { type: 'BET_FORFEIT', amount: escrow.amount, userId: socket.data.userId, description: `Einsatz verfallen: ${room.name}` }
                  })
                }, { isolationLevel: 'Serializable', maxWait: 5000, timeout: 10000 })
              }
            }
          } catch (error) {
            console.error('Disconnect escrow error:', error)
          }
        }
      }

      sendSystemMessage(room.id, io, `${socket.data.displayName} hat den Raum verlassen`)
      io.to(room.id).emit('room:player-left', { userId: socket.data.userId })
    }

    // Now remove from all rooms
    roomManager.removeUserFromAllRooms(socket.data.userId)
    io.emit('room:list-update', roomManager.getPublicRooms())
  })
  ```
  </action>
  <verify>
  1. Grep server.js for `ESCROW_IDEMPOTENT_JOIN` marker -- must return exactly 1 match
  2. Grep server.js for `ESCROW_DISCONNECT_CLEANUP` marker -- must return exactly 1 match
  3. Grep server.js for `existingEscrow` in room:join -- confirms idempotency variable exists
  4. Grep server.js disconnect handler for `betEscrow.findFirst` -- confirms escrow lookup on disconnect
  </verify>
  <done>
  - Rejoining player with existing PENDING/LOCKED escrow does NOT get charged again
  - Disconnecting from bet room pre-game refunds escrow (PENDING -> RELEASED)
  - Disconnecting from bet room mid-game forfeits escrow (LOCKED -> FORFEITED)
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix turn timer scoping and add bet:afk-acknowledge handler</name>
  <files>server.js</files>
  <action>
  Two related turn timer fixes in server.js:

  **A) Move sendSystemMessage and emitBalanceUpdate to module scope:**
  The root cause is that `autoPlay()` (line 280) and `kickPlayerAFK()` (line 446) are defined at module scope (before `app.prepare().then()`), but they call `sendSystemMessage()` (line 573) and `emitBalanceUpdate()` (line 593) which are defined INSIDE the `app.prepare().then()` closure.

  Fix: Move `sendSystemMessage` and `emitBalanceUpdate` OUT of the `app.prepare().then()` closure to module scope, right before the `startTurnTimer` function (around line 250). They only need `roomManager` (module scope) and `io` (passed as parameter), plus `randomUUID` (imported at top).

  Move these two functions from their current locations (lines 573, 593) to module scope (before line 255):
  ```javascript
  // Helper function to send system messages (module scope for timer access)
  function sendSystemMessage(roomId, io, content) {
    const room = roomManager.getRoom(roomId)
    if (!room) return
    const message = {
      id: randomUUID(),
      roomId,
      userId: 'system',
      displayName: 'System',
      content,
      isSystem: true,
      timestamp: Date.now()
    }
    room.chat.push(message)
    if (room.chat.length > 100) room.chat.shift()
    io.to(roomId).emit('chat:message', message)
  }

  // Helper function to emit balance updates (module scope for timer access)
  function emitBalanceUpdate(io, userId, newBalance, change, description) {
    io.to(`user:${userId}`).emit('balance:updated', {
      newBalance,
      change,
      description
    })
  }
  ```

  Remove the duplicate definitions inside `app.prepare().then()`. All call sites already pass `io` as parameter, so no signature changes needed.

  **B) Add error handling to setTimeout in startTurnTimer:**
  Wrap the `autoPlay` call inside setTimeout with try/catch:
  ```javascript
  const timeout = setTimeout(async () => {
    try {
      await autoPlay(roomId, io)
    } catch (error) {
      console.error('Turn timer auto-play error:', error)
    }
  }, room.gameState.turnDuration * 1000)
  ```

  **C) Add bet:afk-acknowledge socket handler:**
  Inside `io.on('connection', ...)`, add a new handler for `bet:afk-acknowledge`:
  ```javascript
  // [AFK_ACKNOWLEDGE_HANDLER]
  socket.on('bet:afk-acknowledge', ({ roomId }) => {
    const room = roomManager.getRoom(roomId)
    if (!room) return

    const warningKey = `${roomId}:${socket.data.userId}`
    const existingWarning = afkWarnings.get(warningKey)

    if (existingWarning) {
      clearTimeout(existingWarning)
      afkWarnings.delete(warningKey)

      // Reset consecutive inactive count
      const player = room.gameState?.players.find(p => p.userId === socket.data.userId)
      if (player) {
        player.consecutiveInactive = 0
      }

      // Notify client warning is canceled
      io.to(`user:${socket.data.userId}`).emit('bet:afk-warning-cancel', { roomId })

      sendSystemMessage(roomId, io, `${socket.data.displayName} ist wieder da`)
    }
  })
  ```
  Place this handler near the other bet/game handlers (after the rematch-vote handler, around line 1385).
  </action>
  <verify>
  1. Grep server.js for `function sendSystemMessage` -- must return exactly 1 match (module scope, no duplicate)
  2. Grep server.js for `function emitBalanceUpdate` -- must return exactly 1 match (module scope, no duplicate)
  3. Grep server.js for `AFK_ACKNOWLEDGE_HANDLER` marker -- must return exactly 1 match
  4. Grep server.js for `try/catch` around autoPlay in startTurnTimer -- confirms error handling
  5. Start the server: `node server.js &`, wait 5 seconds for startup, check for errors in output, then kill the process. Server must start without ReferenceError or other crashes.
  </verify>
  <done>
  - autoPlay and kickPlayerAFK can call sendSystemMessage without ReferenceError
  - Turn timer errors are caught and logged instead of crashing silently
  - bet:afk-acknowledge event resets AFK warning and consecutive inactive counter
  - Server starts cleanly with no immediate errors
  </done>
</task>

</tasks>

<verification>
1. Grep for all 4 marker comments: ESCROW_CREATE_ROOM_CREATE, ESCROW_IDEMPOTENT_JOIN, ESCROW_DISCONNECT_CLEANUP, AFK_ACKNOWLEDGE_HANDLER -- each returns exactly 1 match
2. Grep for `oddsId` in server.js -- returns 0 matches (field does not exist in BetEscrow schema)
3. Grep for `function sendSystemMessage` -- returns exactly 1 match (no duplicate definitions)
4. Grep for `function emitBalanceUpdate` -- returns exactly 1 match (no duplicate definitions)
5. Start server with `node server.js` and confirm no immediate errors (Ctrl+C after startup message)
</verification>

<success_criteria>
- Room creator in bet rooms is charged buy-in with BetEscrow record created (correct 4-field schema: roomId, userId, amount, status)
- Rejoining a room with existing escrow does not create duplicates
- Turn timer expiry correctly triggers auto-play (no silent ReferenceError)
- bet:afk-acknowledge cancels AFK warning and resets inactive counter
- Disconnect from bet room handles escrow cleanup (refund or forfeit based on status)
- Server starts and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-virtual-currency-betting/03-13-SUMMARY.md`
</output>
