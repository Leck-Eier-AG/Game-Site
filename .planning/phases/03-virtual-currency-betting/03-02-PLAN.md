---
phase: 03-virtual-currency-betting
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/wallet/payout.ts
  - src/lib/wallet/escrow.ts
  - src/lib/wallet/__tests__/payout.test.ts
  - src/lib/wallet/__tests__/escrow.test.ts
autonomous: true

must_haves:
  truths:
    - "Prize distribution correctly splits pot based on configurable payout ratios"
    - "Tied players split their position's prize evenly with integer arithmetic"
    - "Total payout always equals total pot (no chips lost or created)"
    - "Escrow state transitions follow valid paths only (PENDING->LOCKED->RELEASED/FORFEITED)"
    - "Invalid escrow transitions are rejected with descriptive errors"
  artifacts:
    - path: "src/lib/wallet/payout.ts"
      provides: "Pure payout calculation with tie splitting and remainder handling"
      exports: ["calculatePayouts", "validatePayoutRatios"]
    - path: "src/lib/wallet/escrow.ts"
      provides: "Escrow state machine with valid transition enforcement"
      exports: ["canTransition", "getValidTransitions", "EscrowTransition"]
    - path: "src/lib/wallet/__tests__/payout.test.ts"
      provides: "Comprehensive payout tests including ties, odd numbers, edge cases"
      min_lines: 80
    - path: "src/lib/wallet/__tests__/escrow.test.ts"
      provides: "Escrow state transition tests covering all valid and invalid paths"
      min_lines: 40
  key_links:
    - from: "src/lib/wallet/payout.ts"
      to: "game end handler"
      via: "calculatePayouts called with pot and rankings"
      pattern: "calculatePayouts"
    - from: "src/lib/wallet/escrow.ts"
      to: "room lifecycle handlers"
      via: "canTransition validates state changes"
      pattern: "canTransition"
---

<objective>
Pure payout calculation and escrow state machine logic, test-driven.

Purpose: Prize distribution and escrow state management are critical financial operations that must be provably correct. TDD ensures edge cases (ties, odd divisions, invalid transitions) are covered before integration. These are pure functions with no database dependency.

Output: Tested payout calculator and escrow state machine, ready for integration into game lifecycle handlers.
</objective>

<execution_context>
@/home/maxi/.claude/get-shit-done/workflows/execute-plan.md
@/home/maxi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-virtual-currency-betting/03-RESEARCH.md
</context>

<feature>
  <name>Payout Calculator</name>
  <files>src/lib/wallet/payout.ts, src/lib/wallet/__tests__/payout.test.ts</files>
  <behavior>
    Calculate prize distribution from pot using configurable payout ratios.

    Core function: calculatePayouts(totalPot: number, rankings: FinalRanking[], ratios: PayoutRatio[]) => Map&lt;string, number&gt;

    Types:
    - FinalRanking: { position: number, userIds: string[] }
    - PayoutRatio: { position: number, percentage: number }

    Test cases (input -> expected output):
    - Standard 3-player: pot=1000, ratios=[60,30,10], ranks=[{1,['a']},{2,['b']},{3,['c']}] -> a:600, b:300, c:100
    - 2-way tie for 1st: pot=1000, ratios=[60,30,10], ranks=[{1,['a','b']},{3,['c']}] -> a:300, b:300, c:100 (1st+2nd pooled: 900/2=450 each? NO: per user decision, tied players split the prize for THEIR position. So 1st place gets 60%=600, split 2: a:300, b:300. 2nd place skipped. 3rd: c:100)
    - 3-way tie for 1st: pot=1000, ratios=[60,30,10], ranks=[{1,['a','b','c']}] -> 600/3=200 each
    - Odd remainder: pot=997, ratios=[60,30,10], ranks=[{1,['a','b','c']}] -> 598/3=199 each + 1 remainder to first in list -> [200, 199, 199]
    - 2-player game: pot=500, ratios=[60,30,10], ranks=[{1,['a']},{2,['b']}] -> a:300, b:150 (3rd place unclaimed)
    - Single winner (all others forfeit): pot=800, ratios=[60,30,10], ranks=[{1,['a']}] -> a:800 (pot goes to sole finisher)
    - Total payout invariant: sum of all payouts == totalPot for all test cases

    Also: validatePayoutRatios(ratios) -> returns boolean. Ratios must sum to 100%, positions must be sequential starting at 1.
  </behavior>
  <implementation>
    Pure function using integer arithmetic throughout. Math.floor for division, remainder distributed to highest position players. When only one finisher remains (all others forfeited), that player gets entire pot regardless of ratios. validatePayoutRatios checks sum===100 and sequential positions.
  </implementation>
</feature>

<feature>
  <name>Escrow State Machine</name>
  <files>src/lib/wallet/escrow.ts, src/lib/wallet/__tests__/escrow.test.ts</files>
  <behavior>
    Enforce valid escrow state transitions.

    States: PENDING, LOCKED, RELEASED, FORFEITED
    Valid transitions:
    - PENDING -> LOCKED (game starts)
    - PENDING -> RELEASED (player leaves before game starts = refund)
    - LOCKED -> RELEASED (game ends, payout distributed)
    - LOCKED -> FORFEITED (player leaves mid-game or AFK kicked)

    Invalid transitions (must be rejected):
    - RELEASED -> anything
    - FORFEITED -> anything
    - PENDING -> FORFEITED (can't forfeit before game starts)
    - LOCKED -> PENDING (can't go back to pending)

    Functions:
    - canTransition(from: EscrowStatus, to: EscrowStatus): boolean
    - getValidTransitions(from: EscrowStatus): EscrowStatus[]
    - EscrowTransition type: { from: EscrowStatus, to: EscrowStatus, reason: string }
  </behavior>
  <implementation>
    Transition table as const object mapping each state to allowed next states. canTransition does simple lookup. getValidTransitions returns the array for given state. Use string literal types matching Prisma enum values.
  </implementation>
</feature>

<verification>
`npm test -- --testPathPattern="wallet"` all tests pass. No test skipped or pending.
</verification>

<success_criteria>
All payout calculation tests pass including tie splitting and remainder handling. Total payout always equals total pot. Escrow state machine rejects all invalid transitions. Test coverage includes edge cases.
</success_criteria>

<output>
After completion, create `.planning/phases/03-virtual-currency-betting/03-02-SUMMARY.md`
</output>
