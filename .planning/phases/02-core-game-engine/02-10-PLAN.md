---
phase: 02-core-game-engine
plan: 10
type: execute
wave: 4
depends_on: ["02-02", "02-03", "02-09"]
files_modified:
  - server.js
  - src/components/game/RematchVote.tsx
  - src/components/game/GameResults.tsx
autonomous: true

must_haves:
  truths:
    - "Turn timer auto-plays best category on timeout"
    - "AFK players are kicked after threshold consecutive inactive rounds"
    - "Players can vote for rematch after game ends"
    - "Game results screen shows winner and final scores"
    - "Rematch accepted resets to waiting room, declined returns to lobby"
  artifacts:
    - path: "server.js"
      provides: "Timer management, auto-play, AFK detection, rematch voting"
      contains: "startTurnTimer"
    - path: "src/components/game/RematchVote.tsx"
      provides: "Post-game rematch voting UI"
      exports: ["RematchVote"]
    - path: "src/components/game/GameResults.tsx"
      provides: "End-of-game results display"
      exports: ["GameResults"]
  key_links:
    - from: "server.js (autoPlay)"
      to: "src/lib/game/kniffel-rules.ts"
      via: "imports autoPickCategory for auto-play on timeout"
      pattern: "autoPickCategory"
    - from: "server.js (autoPlay)"
      to: "src/lib/game/state-machine.ts"
      via: "uses applyAction to process auto-play actions"
      pattern: "applyAction"
    - from: "server.js (turnTimer)"
      to: "setTimeout/clearTimeout"
      via: "turn timer management with Map of room timers"
      pattern: "setTimeout.*autoPlay|turnTimers"
---

<objective>
Add turn timer management, auto-play on timeout, AFK detection/kick, rematch voting to server.js, plus client-side GameResults and RematchVote components.

Purpose: This completes the game experience with time pressure (turn timers), fairness (AFK removal), and replayability (rematch voting). Split from core game handlers (Plan 02-09) to keep scope manageable. Auto-play uses the imported autoPickCategory from kniffel-rules.ts.
Output: Turn timer + auto-play + AFK logic in server.js, GameResults and RematchVote client components.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-game-engine/02-CONTEXT.md
@.planning/phases/02-core-game-engine/02-RESEARCH.md
@server.js
@src/types/game.ts
@src/lib/game/kniffel-rules.ts
@src/lib/game/state-machine.ts
@src/messages/de.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add turn timer, auto-play, AFK detection, and rematch to server.js</name>
  <files>server.js</files>
  <action>
Add timer management, auto-play, AFK detection, and rematch voting to server.js. These extend the core game handlers from Plan 02-09. Use the imported modules (autoPickCategory, calculateScore, applyAction from kniffel-rules.ts and state-machine.ts).

1. **Turn timer management:**
```javascript
const turnTimers = new Map() // roomId -> timeout

function startTurnTimer(roomId) {
  clearTurnTimer(roomId)
  const room = roomManager.getRoom(roomId)
  if (!room || !room.gameState || room.gameState.phase === 'ended') return

  const timeout = setTimeout(() => {
    autoPlay(roomId)
  }, room.gameState.turnDuration * 1000)

  turnTimers.set(roomId, timeout)
}

function resetTurnTimer(roomId) {
  startTurnTimer(roomId) // clear and restart
}

function clearTurnTimer(roomId) {
  const timer = turnTimers.get(roomId)
  if (timer) { clearTimeout(timer); turnTimers.delete(roomId) }
}
```

2. **Auto-play on timeout using imported autoPickCategory:**
```javascript
function autoPlay(roomId) {
  const room = roomManager.getRoom(roomId)
  if (!room || !room.gameState || room.gameState.phase === 'ended') return
  const gs = room.gameState
  const currentPlayer = gs.players[gs.currentPlayerIndex]

  // If player hasn't rolled yet, roll for them via state machine
  let state = gs
  if (state.rollsRemaining === 3) {
    const newDice = rollDice(5)
    const rollAction = { type: 'ROLL_DICE', keptDice: [false,false,false,false,false], newDice }
    const rollResult = applyAction(state, rollAction, currentPlayer.userId)
    if (!(rollResult instanceof Error)) {
      state = rollResult
    }
  }

  // Pick best category using imported autoPickCategory from kniffel-rules.ts
  const bestCategory = autoPickCategory(state.dice, currentPlayer.scoresheet)

  // Apply scoring via state machine
  const scoreAction = { type: 'CHOOSE_CATEGORY', category: bestCategory }
  const result = applyAction(state, scoreAction, currentPlayer.userId)

  if (result instanceof Error) {
    // Fallback: something went wrong, log and skip turn
    console.error('Auto-play failed:', result.message)
    return
  }

  room.gameState = result
  currentPlayer.consecutiveInactive += 1

  const score = calculateScore(bestCategory, state.dice)
  sendSystemMessage(roomId, `Auto-Zug: ${currentPlayer.displayName} -> ${bestCategory} (${score} Punkte)`)

  // Check AFK threshold
  if (currentPlayer.consecutiveInactive >= room.afkThreshold) {
    kickPlayerAFK(room, roomId, currentPlayer)
  }

  // Check if game ended
  if (result.phase === 'ended') {
    room.status = 'ended'
    clearTurnTimer(roomId)
    const winnerPlayer = result.players.find(p => p.userId === result.winner)
    const winnerTotal = calculateTotalScore(winnerPlayer.scoresheet)
    sendSystemMessage(roomId, `Spiel beendet! Gewinner: ${winnerPlayer.displayName} (${winnerTotal} Punkte)`)
    room.rematchVotes = { votedYes: [], votedNo: [], total: result.players.length, required: Math.ceil(result.players.length / 2) }
    io.to(roomId).emit('game:ended', { winner: result.winner, scores: result.players.map(p => ({ userId: p.userId, displayName: p.displayName, total: calculateTotalScore(p.scoresheet) })) })
    io.emit('room:list-update', roomManager.getPublicRooms())
  } else {
    result.turnStartedAt = Date.now()
    startTurnTimer(roomId)
  }

  io.to(roomId).emit('game:state-update', { state: result, roomId })
}
```

3. **AFK kick:**
```javascript
function kickPlayerAFK(room, roomId, player) {
  sendSystemMessage(roomId, `${player.displayName} wurde entfernt (AFK)`)
  room.gameState.players = room.gameState.players.filter(p => p.userId !== player.userId)
  room.players = room.players.filter(p => p.userId !== player.userId)

  // If only 1 player left, they win by default
  if (room.gameState.players.length < 2) {
    room.gameState.phase = 'ended'
    room.gameState.winner = room.gameState.players[0]?.userId || null
    room.status = 'ended'
    clearTurnTimer(roomId)
    const winner = room.gameState.players[0]
    if (winner) {
      sendSystemMessage(roomId, `${winner.displayName} gewinnt! Alle anderen Spieler waren AFK.`)
    }
    io.to(roomId).emit('game:ended', { winner: room.gameState.winner, scores: room.gameState.players.map(p => ({ userId: p.userId, displayName: p.displayName, total: calculateTotalScore(p.scoresheet) })) })
    return
  }

  // Adjust currentPlayerIndex if needed
  if (room.gameState.currentPlayerIndex >= room.gameState.players.length) {
    room.gameState.currentPlayerIndex = 0
  }

  io.to(roomId).emit('room:player-kicked', { userId: player.userId, reason: 'AFK' })
}
```

4. **Rematch voting handler:**
```javascript
socket.on('game:rematch-vote', ({ roomId, vote }, callback) => {
  const room = roomManager.getRoom(roomId)
  if (!room || !room.rematchVotes) { callback?.({ error: 'No vote active' }); return }

  const rv = room.rematchVotes
  // Remove existing vote from this user
  rv.votedYes = rv.votedYes.filter(id => id !== socket.data.userId)
  rv.votedNo = rv.votedNo.filter(id => id !== socket.data.userId)

  if (vote) rv.votedYes.push(socket.data.userId)
  else rv.votedNo.push(socket.data.userId)

  io.to(roomId).emit('game:rematch-update', rv)

  // Check if majority voted yes
  if (rv.votedYes.length >= rv.required) {
    room.status = 'waiting'
    room.gameState = null
    room.rematchVotes = null
    for (const p of room.players) { p.isReady = false }
    io.to(roomId).emit('game:rematch-accepted')
    sendSystemMessage(roomId, 'Noch eine Runde! Alle bereit machen...')
    io.emit('room:list-update', roomManager.getPublicRooms())
  } else if (rv.votedNo.length > rv.total - rv.required) {
    io.to(roomId).emit('game:rematch-declined')
    sendSystemMessage(roomId, 'Kein Rematch. Zurueck zur Lobby.')
  }

  callback?.({ success: true })
})
```

Important: autoPlay uses the imported autoPickCategory from kniffel-rules.ts -- this ensures the auto-play strategy is consistent with the tested scoring logic. No inline scoring duplication.
  </action>
  <verify>
`npx tsx server.js` starts without errors (or `node --check server.js` for syntax).
Turn timer functions exist: startTurnTimer, resetTurnTimer, clearTurnTimer.
autoPlay function uses imported autoPickCategory and applyAction.
AFK kick logic present with threshold check.
game:rematch-vote handler registered.
Grep for "calculateScoreServer" -- should NOT exist.
  </verify>
  <done>
Turn timers with auto-play on timeout using imported autoPickCategory.
AFK detection kicks players after threshold consecutive inactive rounds.
Rematch voting with majority acceptance.
All auto-play logic uses imported state machine and scoring modules (no duplication).
  </done>
</task>

<task type="auto">
  <name>Task 2: Build GameResults and RematchVote components</name>
  <files>
    src/components/game/GameResults.tsx
    src/components/game/RematchVote.tsx
  </files>
  <action>
Create src/components/game/GameResults.tsx ('use client'):

End-of-game results screen showing:
1. Winner announcement with trophy icon and "Gewinner: {name}" text
2. Final standings table: rank, player name, total score, upper bonus indicator
3. Detailed scoresheet: expand to see full category-by-category breakdown for all players
4. Smooth transition from game board to results

Layout:
- Large trophy/celebration animation area at top
- Podium-style ranking (1st gold, 2nd silver, 3rd bronze)
- Scores table below with all players ranked by total score
- "Noch eine Runde?" section at bottom (RematchVote)

Props:
```typescript
interface GameResultsProps {
  players: Array<{ userId: string; displayName: string; totalScore: number; scoresheet: KniffelScoresheet }>
  winnerId: string | null
  currentUserId: string
}
```

Create src/components/game/RematchVote.tsx ('use client'):

Post-game rematch voting component:
1. "Noch eine Runde?" title
2. Two buttons: "Ja, nochmal!" (green) and "Nein, danke" (gray)
3. Progress indicator: "{votedYes}/{required} stimmen fuer Rematch"
4. List of who voted (names with check/X icons)
5. "Zurueck zur Lobby" link for players who decline
6. Auto-navigate to lobby if rematch declined, or reset to waiting room if accepted

Socket events:
- Listen: 'game:rematch-update' -> update vote counts
- Listen: 'game:rematch-accepted' -> transition to waiting room
- Listen: 'game:rematch-declined' -> navigate to lobby
- Emit: 'game:rematch-vote' with { roomId, vote: boolean }

Props:
```typescript
interface RematchVoteProps {
  roomId: string
  socket: Socket
  rematchVotes: RematchVote
  currentUserId: string
}
```
  </action>
  <verify>
`npx tsc --noEmit` passes.
`npm run build` passes.
GameResults and RematchVote export correctly.
  </verify>
  <done>
GameResults shows winner, rankings, final scores with detailed scoresheet breakdown.
RematchVote enables "Noch eine Runde?" voting with majority threshold.
Rematch accepted -> back to waiting room. Declined -> back to lobby.
All German translations used.
  </done>
</task>

</tasks>

<verification>
- `npx tsx server.js` starts without errors
- `npm run build` passes
- Auto-play triggers on turn timeout using imported autoPickCategory
- AFK kick after threshold inactive rounds
- Rematch voting with majority logic
- GameResults displays winner and scores
- RematchVote enables post-game voting
</verification>

<success_criteria>
- Turn timer auto-plays on timeout with autoPickCategory from kniffel-rules.ts
- AFK players kicked after consecutive inactive threshold
- Rematch voting with majority acceptance resets to waiting room
- Results screen shows rankings and detailed scores
- Zero inline scoring logic -- all via imported modules
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-engine/02-10-SUMMARY.md`
</output>
