---
phase: 02-core-game-engine
plan: 09
type: execute
wave: 4
depends_on: ["02-02", "02-03", "02-04", "02-07"]
files_modified:
  - server.js
autonomous: true

must_haves:
  truths:
    - "Server-side game logic processes dice rolls using imported state machine"
    - "Server-side scoring uses imported kniffel-rules.ts calculateScore"
    - "Category selection advances turns via imported advanceTurn"
    - "Game ends after 13 rounds with winner determined via imported checkGameEnd"
    - "All state transitions are validated by the state machine (no illegal moves)"
  artifacts:
    - path: "server.js"
      provides: "Game action handlers using state-machine.ts and kniffel-rules.ts"
      contains: "game:roll-dice"
  key_links:
    - from: "server.js"
      to: "src/lib/game/state-machine.ts"
      via: "imports applyAction, createInitialState, advanceTurn, checkGameEnd"
      pattern: "import.*applyAction|import.*createInitialState|from.*state-machine"
    - from: "server.js"
      to: "src/lib/game/kniffel-rules.ts"
      via: "imports calculateScore, autoPickCategory, calculateTotalScore"
      pattern: "import.*calculateScore|import.*autoPickCategory|from.*kniffel-rules"
    - from: "server.js"
      to: "src/lib/game/crypto-rng.ts"
      via: "imports rollFiveDice for server-side dice generation"
      pattern: "import.*rollFiveDice|from.*crypto-rng"
---

<objective>
Wire up the core server-side game loop: game start, dice rolling, category selection, turn advancement, and game end -- all using the state machine and scoring modules built in Plans 02-02 and 02-03.

Purpose: This plan connects the state machine (state-machine.ts) and scoring rules (kniffel-rules.ts) to the server's Socket.IO handlers. The server is authoritative (SPIEL-07) -- all game actions flow through the state machine to prevent illegal moves. No scoring or state logic is reimplemented; it is imported from the existing modules.
Output: server.js with game:start, game:player-ready, game:roll-dice, game:choose-category handlers that delegate to imported state machine and scoring functions.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-game-engine/02-CONTEXT.md
@.planning/phases/02-core-game-engine/02-RESEARCH.md
@server.js
@src/types/game.ts
@src/lib/game/state-machine.ts
@src/lib/game/kniffel-rules.ts
@src/lib/game/crypto-rng.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up TS module imports in server.js</name>
  <files>server.js</files>
  <action>
The state machine, scoring rules, and crypto-rng are written in TypeScript but server.js is plain Node.js. To import them, use one of these approaches (choose the simplest that works):

**Option A (preferred): Use tsx or ts-node to run server.js as TS-aware.**
Change the server start script in package.json from `node server.js` to `tsx server.js` (tsx is a lightweight TS runner for Node.js). Install tsx as a dev dependency: `npm install -D tsx`. This lets server.js use `import` from .ts files directly with path aliases resolved.

**Option B: Compile the game modules to JS first.**
Add a build step that compiles src/lib/game/*.ts to a dist/ folder, then import from dist/. More complex, less desirable for MVP.

**Option C: Use dynamic import with tsconfig paths resolved at runtime.**
Use `tsconfig-paths/register` to resolve @/ aliases, combined with tsx or ts-node.

Go with **Option A**. Steps:
1. Install tsx: `npm install -D tsx`
2. Update package.json "dev:server" or equivalent script to use `tsx server.js` instead of `node server.js`
3. At the top of server.js, add imports from the TS modules:

```javascript
import { createInitialState, applyAction, isValidAction, advanceTurn, checkGameEnd } from './src/lib/game/state-machine.js'
import { calculateScore, getAvailableCategories, calculateUpperBonus, autoPickCategory, calculateTotalScore } from './src/lib/game/kniffel-rules.js'
import { rollFiveDice, rollDice } from './src/lib/game/crypto-rng.js'
```

Note: With tsx, you import .ts files using .js extension (or no extension). Test which works. If path aliases (@/) don't resolve, use relative paths as shown above.

4. Remove the existing `import { randomInt } from 'node:crypto'` line if present -- dice rolling now comes from crypto-rng.ts.

5. Verify the imports work by running `tsx server.js` and checking for import errors.
  </action>
  <verify>
Run `npx tsx server.js` briefly (Ctrl+C after startup) -- no import errors for state-machine, kniffel-rules, or crypto-rng.
All three modules are importable from server.js.
  </verify>
  <done>
server.js can import createInitialState, applyAction, advanceTurn, checkGameEnd from state-machine.ts.
server.js can import calculateScore, autoPickCategory, calculateTotalScore, getAvailableCategories from kniffel-rules.ts.
server.js can import rollFiveDice from crypto-rng.ts.
No duplicate scoring or state logic in server.js.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement core game handlers using imported modules</name>
  <files>server.js</files>
  <action>
Add game event handlers to server.js inside the io.on('connection') block. All game logic delegates to the imported state machine and scoring modules. Do NOT reimplement scoring or state transitions inline.

1. **game:player-ready** - Player toggles ready state:
```javascript
socket.on('game:player-ready', ({ roomId }, callback) => {
  const room = roomManager.getRoom(roomId)
  if (!room || room.status !== 'waiting') { callback?.({ error: 'Invalid' }); return }
  const player = room.players.find(p => p.userId === socket.data.userId)
  if (!player) { callback?.({ error: 'Not in room' }); return }
  player.isReady = !player.isReady
  io.to(roomId).emit('room:player-ready', { userId: socket.data.userId, isReady: player.isReady })
  callback?.({ success: true, isReady: player.isReady })
})
```

2. **game:start** - Host starts the game:
```javascript
socket.on('game:start', ({ roomId }, callback) => {
  const room = roomManager.getRoom(roomId)
  if (!room) { callback?.({ error: 'Room not found' }); return }
  if (room.hostId !== socket.data.userId) { callback?.({ error: 'Not host' }); return }

  const readyPlayers = room.players.filter(p => p.isReady)
  if (readyPlayers.length < 2) { callback?.({ error: 'Need at least 2 ready players' }); return }

  // Move non-ready players to spectators
  const notReady = room.players.filter(p => !p.isReady)
  for (const p of notReady) {
    room.spectators.push(p.userId)
    sendSystemMessage(roomId, `${p.displayName} schaut zu (nicht bereit)`)
  }
  room.players = readyPlayers

  // Use imported createInitialState from state-machine.ts
  const playerData = readyPlayers.map(p => ({
    userId: p.userId,
    displayName: p.displayName
  }))
  const settings = { turnDuration: room.turnTimer }
  room.gameState = createInitialState(playerData, settings)
  room.status = 'playing'

  sendSystemMessage(roomId, 'Das Spiel beginnt!')
  io.to(roomId).emit('game:state-update', { state: room.gameState, roomId })
  io.emit('room:list-update', roomManager.getPublicRooms())

  // Start turn timer (added by Plan 02-10)
  if (typeof startTurnTimer === 'function') startTurnTimer(roomId)
  callback?.({ success: true })
})
```

3. **game:roll-dice** - Player rolls dice:
```javascript
socket.on('game:roll-dice', ({ roomId, keptDice }, callback) => {
  const room = roomManager.getRoom(roomId)
  if (!room || !room.gameState) { callback?.({ error: 'No game' }); return }
  const gs = room.gameState

  // Generate new dice via imported crypto-rng
  const newDiceValues = rollDice(5)

  // Apply action via imported state machine
  const action = {
    type: 'ROLL_DICE',
    keptDice: keptDice || [false, false, false, false, false],
    newDice: newDiceValues
  }
  const result = applyAction(gs, action, socket.data.userId)

  if (result instanceof Error) {
    callback?.({ error: result.message }); return
  }

  // Update game state with result from state machine
  room.gameState = result

  const currentPlayer = result.players[result.currentPlayerIndex]
  currentPlayer.lastActivity = Date.now()
  currentPlayer.consecutiveInactive = 0

  // Reset turn timer
  result.turnStartedAt = Date.now()
  if (typeof resetTurnTimer === 'function') resetTurnTimer(roomId)

  io.to(roomId).emit('game:state-update', { state: result, roomId })
  sendSystemMessage(roomId, `${currentPlayer.displayName} hat gewuerfelt`)
  callback?.({ success: true, dice: result.dice })
})
```

4. **game:choose-category** - Player picks scoring category:
```javascript
socket.on('game:choose-category', ({ roomId, category }, callback) => {
  const room = roomManager.getRoom(roomId)
  if (!room || !room.gameState) { callback?.({ error: 'No game' }); return }
  const gs = room.gameState

  // Apply action via imported state machine (which internally uses calculateScore)
  const action = { type: 'CHOOSE_CATEGORY', category }
  const result = applyAction(gs, action, socket.data.userId)

  if (result instanceof Error) {
    callback?.({ error: result.message }); return
  }

  // Update game state
  room.gameState = result
  const scoredPlayer = gs.players[gs.currentPlayerIndex]
  const score = calculateScore(category, gs.dice)

  sendSystemMessage(roomId, `${scoredPlayer.displayName} hat ${category} gewaehlt (${score} Punkte)`)

  // Check if game ended
  if (result.phase === 'ended') {
    room.status = 'ended'
    clearTurnTimer(roomId)
    const winnerPlayer = result.players.find(p => p.userId === result.winner)
    const winnerTotal = calculateTotalScore(winnerPlayer.scoresheet)
    sendSystemMessage(roomId, `Spiel beendet! Gewinner: ${winnerPlayer.displayName} (${winnerTotal} Punkte)`)

    // Initialize rematch voting
    room.rematchVotes = {
      votedYes: [], votedNo: [],
      total: result.players.length,
      required: Math.ceil(result.players.length / 2)
    }

    io.to(roomId).emit('game:ended', {
      winner: result.winner,
      scores: result.players.map(p => ({
        userId: p.userId,
        displayName: p.displayName,
        total: calculateTotalScore(p.scoresheet)
      }))
    })
    io.emit('room:list-update', roomManager.getPublicRooms())
  } else {
    // Restart turn timer for next player
    result.turnStartedAt = Date.now()
    if (typeof startTurnTimer === 'function') startTurnTimer(roomId)
  }

  io.to(roomId).emit('game:state-update', { state: result, roomId })
  callback?.({ success: true, score })
})
```

Important: The state machine's applyAction handles:
- Validating it's the correct player's turn
- Checking rollsRemaining > 0 for ROLL_DICE
- Checking category is available for CHOOSE_CATEGORY
- Calculating and recording the score
- Advancing the turn (via advanceTurn)
- Detecting game end (via checkGameEnd)

The server just orchestrates: calls applyAction, broadcasts results, manages timers. Zero inline scoring or state transition logic.

If the state machine's applyAction doesn't call advanceTurn/checkGameEnd internally (some implementations return intermediate state), then call them explicitly:
```javascript
// After CHOOSE_CATEGORY succeeds:
let newState = applyAction(gs, action, socket.data.userId)
if (!(newState instanceof Error)) {
  newState = advanceTurn(newState)
  newState = checkGameEnd(newState)
  room.gameState = newState
}
```

Adapt based on the actual state-machine.ts implementation.
  </action>
  <verify>
`npx tsx --check server.js` or `npx tsx server.js` starts without errors.
Server handles: game:start, game:player-ready, game:roll-dice, game:choose-category.
No inline calculateScore or state transition logic -- all imported from modules.
Grep server.js for "calculateScoreServer" -- should NOT exist (old inline version removed).
  </verify>
  <done>
Core game loop in server.js: start -> roll -> score -> advance -> end.
All dice values generated via imported rollDice from crypto-rng.ts (SPIEL-07 compliance).
All state transitions via imported applyAction from state-machine.ts.
All scoring via imported calculateScore from kniffel-rules.ts.
System messages for all game events.
  </done>
</task>

</tasks>

<verification>
- `npx tsx server.js` starts without import errors
- Server processes complete core game loop: start -> roll -> score -> advance -> end
- State transitions delegated to state-machine.ts (applyAction, advanceTurn, checkGameEnd)
- Scoring delegated to kniffel-rules.ts (calculateScore, calculateTotalScore)
- Dice generation delegated to crypto-rng.ts (rollDice, rollFiveDice)
- No duplicate/inline scoring or state logic in server.js
</verification>

<success_criteria>
- server.js imports from state-machine.ts, kniffel-rules.ts, and crypto-rng.ts
- game:roll-dice uses applyAction with ROLL_DICE action type
- game:choose-category uses applyAction with CHOOSE_CATEGORY action type
- Game end detection via checkGameEnd from state machine
- Zero inline scoring functions in server.js
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-engine/02-09-SUMMARY.md`
</output>
