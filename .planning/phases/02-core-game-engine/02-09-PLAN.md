---
phase: 02-core-game-engine
plan: 09
type: execute
wave: 4
depends_on: ["02-03", "02-04", "02-07", "02-08"]
files_modified:
  - server.js
  - src/components/game/RematchVote.tsx
  - src/components/game/GameResults.tsx
autonomous: true

must_haves:
  truths:
    - "Server-side game logic processes dice rolls, category selection, and turn advancement"
    - "Turn timer auto-plays best category on timeout"
    - "AFK players are kicked after threshold consecutive inactive rounds"
    - "Game ends after 13 rounds with winner determined"
    - "Players can vote for rematch after game ends"
    - "Empty rooms cleaned up after all players leave"
  artifacts:
    - path: "server.js"
      provides: "Game action handlers and timer/AFK management"
      contains: "game:roll-dice"
    - path: "src/components/game/RematchVote.tsx"
      provides: "Post-game rematch voting UI"
      exports: ["RematchVote"]
    - path: "src/components/game/GameResults.tsx"
      provides: "End-of-game results display"
      exports: ["GameResults"]
  key_links:
    - from: "server.js"
      to: "state machine logic"
      via: "applyAction or inline state transitions"
      pattern: "applyAction|rollsRemaining|currentPlayerIndex"
    - from: "server.js"
      to: "crypto.randomInt"
      via: "server-side dice generation"
      pattern: "randomInt"
    - from: "server.js"
      to: "auto-play logic"
      via: "setTimeout for turn timer"
      pattern: "setTimeout.*autoPlay|turnTimer"
---

<objective>
Wire up the complete server-side game loop: dice rolling, category selection, turn timers with auto-play, AFK detection/kick, game end, and rematch voting. Plus client-side results and rematch UI.

Purpose: This plan connects all the pieces built in prior plans into a working game. The server processes all game actions (server-authoritative, SPIEL-07), manages timers, handles AFK, and determines winners. The client gets results display and rematch voting.
Output: Complete game loop in server.js, RematchVote and GameResults components.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-game-engine/02-CONTEXT.md
@.planning/phases/02-core-game-engine/02-RESEARCH.md
@server.js
@src/types/game.ts
@src/messages/de.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement game action handlers and timer management in server.js</name>
  <files>server.js</files>
  <action>
Add game event handlers to server.js. Since the state machine (Plan 02-03) is written in TypeScript and server.js is plain JS, either:
- Option A: Reimplement the core state transition logic in JS directly in server.js
- Option B: Use a compiled version

Use Option A for simplicity -- inline the game logic in server.js since it needs to interact with RoomManager directly.

Add these handlers inside io.on('connection'):

1. **game:start** - Host starts the game:
```javascript
socket.on('game:start', ({ roomId }, callback) => {
  const room = roomManager.getRoom(roomId)
  if (!room) { callback?.({ error: 'Room not found' }); return }
  if (room.hostId !== socket.data.userId) { callback?.({ error: 'Not host' }); return }

  const readyPlayers = room.players.filter(p => p.isReady)
  if (readyPlayers.length < 2) { callback?.({ error: 'Need at least 2 ready players' }); return }

  // Remove non-ready players (they become spectators)
  const notReady = room.players.filter(p => !p.isReady)
  for (const p of notReady) {
    room.spectators.push(p.userId)
    sendSystemMessage(roomId, `${p.displayName} schaut zu (nicht bereit)`)
  }
  room.players = readyPlayers

  // Initialize game state
  room.status = 'playing'
  room.gameState = {
    phase: 'rolling',
    players: room.players.map(p => ({
      userId: p.userId,
      displayName: p.displayName,
      scoresheet: {},
      isReady: true,
      isConnected: true,
      lastActivity: Date.now(),
      consecutiveInactive: 0
    })),
    spectators: room.spectators,
    currentPlayerIndex: 0,
    dice: [1, 1, 1, 1, 1],
    keptDice: [false, false, false, false, false],
    rollsRemaining: 3,
    round: 1,
    turnStartedAt: Date.now(),
    turnDuration: room.turnTimer,
    winner: null
  }

  sendSystemMessage(roomId, 'Das Spiel beginnt!')
  io.to(roomId).emit('game:state-update', { state: room.gameState, roomId })
  io.emit('room:list-update', roomManager.getPublicRooms())

  // Start turn timer
  startTurnTimer(roomId)
  callback?.({ success: true })
})
```

2. **game:player-ready** - Player toggles ready state:
```javascript
socket.on('game:player-ready', ({ roomId }, callback) => {
  const room = roomManager.getRoom(roomId)
  if (!room || room.status !== 'waiting') { callback?.({ error: 'Invalid' }); return }
  const player = room.players.find(p => p.userId === socket.data.userId)
  if (!player) { callback?.({ error: 'Not in room' }); return }
  player.isReady = !player.isReady
  io.to(roomId).emit('room:player-ready', { userId: socket.data.userId, isReady: player.isReady })
  callback?.({ success: true, isReady: player.isReady })
})
```

3. **game:roll-dice** - Player rolls dice:
```javascript
socket.on('game:roll-dice', ({ roomId, keptDice }, callback) => {
  const room = roomManager.getRoom(roomId)
  if (!room || !room.gameState) { callback?.({ error: 'No game' }); return }
  const gs = room.gameState
  const currentPlayer = gs.players[gs.currentPlayerIndex]
  if (currentPlayer.userId !== socket.data.userId) { callback?.({ error: 'Not your turn' }); return }
  if (gs.rollsRemaining <= 0) { callback?.({ error: 'No rolls remaining' }); return }

  // Generate new dice values (server-side crypto RNG - SPIEL-07)
  const newDice = gs.dice.map((d, i) =>
    keptDice[i] ? d : randomInt(1, 7)
  )

  gs.dice = newDice
  gs.keptDice = keptDice
  gs.rollsRemaining -= 1
  gs.phase = 'rolling'

  // Update activity
  currentPlayer.lastActivity = Date.now()
  currentPlayer.consecutiveInactive = 0

  // Reset turn timer
  gs.turnStartedAt = Date.now()
  resetTurnTimer(roomId)

  io.to(roomId).emit('game:state-update', { state: gs, roomId })
  sendSystemMessage(roomId, `${currentPlayer.displayName} hat gewuerfelt`)
  callback?.({ success: true, dice: newDice })
})
```

4. **game:choose-category** - Player picks scoring category:
```javascript
socket.on('game:choose-category', ({ roomId, category }, callback) => {
  const room = roomManager.getRoom(roomId)
  if (!room || !room.gameState) { callback?.({ error: 'No game' }); return }
  const gs = room.gameState
  const currentPlayer = gs.players[gs.currentPlayerIndex]
  if (currentPlayer.userId !== socket.data.userId) { callback?.({ error: 'Not your turn' }); return }
  if (gs.rollsRemaining === 3) { callback?.({ error: 'Must roll first' }); return }

  // Check category not already scored
  if (currentPlayer.scoresheet[category] !== undefined) {
    callback?.({ error: 'Category already scored' }); return
  }

  // Calculate score (inline scoring logic from kniffel-rules)
  const score = calculateScoreServer(category, gs.dice)
  currentPlayer.scoresheet[category] = score
  currentPlayer.lastActivity = Date.now()
  currentPlayer.consecutiveInactive = 0

  sendSystemMessage(roomId, `${currentPlayer.displayName} hat ${getCategoryName(category)} gewaehlt (${score} Punkte)`)

  // Advance turn
  advanceTurn(room)

  io.to(roomId).emit('game:state-update', { state: gs, roomId })
  callback?.({ success: true, score })
})
```

5. **Turn timer management:**
```javascript
const turnTimers = new Map() // roomId -> timeout

function startTurnTimer(roomId) {
  clearTurnTimer(roomId)
  const room = roomManager.getRoom(roomId)
  if (!room || !room.gameState || room.gameState.phase === 'ended') return

  const timeout = setTimeout(() => {
    autoPlay(roomId)
  }, room.gameState.turnDuration * 1000)

  turnTimers.set(roomId, timeout)
}

function resetTurnTimer(roomId) {
  startTurnTimer(roomId) // clear and restart
}

function clearTurnTimer(roomId) {
  const timer = turnTimers.get(roomId)
  if (timer) { clearTimeout(timer); turnTimers.delete(roomId) }
}
```

6. **Auto-play on timeout:**
```javascript
function autoPlay(roomId) {
  const room = roomManager.getRoom(roomId)
  if (!room || !room.gameState || room.gameState.phase === 'ended') return
  const gs = room.gameState
  const currentPlayer = gs.players[gs.currentPlayerIndex]

  // If player hasn't rolled yet, roll for them
  if (gs.rollsRemaining === 3) {
    gs.dice = Array(5).fill(0).map(() => randomInt(1, 7))
    gs.rollsRemaining = 0
  }

  // Pick best available category (greedy: highest immediate score)
  const available = getAllCategories().filter(c => currentPlayer.scoresheet[c] === undefined)
  let bestCategory = available[0]
  let bestScore = 0
  for (const cat of available) {
    const s = calculateScoreServer(cat, gs.dice)
    if (s > bestScore) { bestScore = s; bestCategory = cat }
  }

  // If all zero, pick first available (least wasteful strategy: pick "chance" if available, else first)
  if (bestScore === 0) {
    bestCategory = available.includes('chance') ? 'chance' : available[0]
    bestScore = calculateScoreServer(bestCategory, gs.dice)
  }

  currentPlayer.scoresheet[bestCategory] = bestScore
  currentPlayer.consecutiveInactive += 1

  sendSystemMessage(roomId, `Auto-Zug: ${currentPlayer.displayName} -> ${getCategoryName(bestCategory)} (${bestScore} Punkte)`)

  // Check AFK threshold
  if (currentPlayer.consecutiveInactive >= room.afkThreshold) {
    kickPlayerAFK(room, roomId, currentPlayer)
  }

  advanceTurn(room)
  io.to(roomId).emit('game:state-update', { state: gs, roomId })
}
```

7. **advanceTurn helper:**
```javascript
function advanceTurn(room) {
  const gs = room.gameState
  // Move to next player
  gs.currentPlayerIndex = (gs.currentPlayerIndex + 1) % gs.players.length

  // Check if round complete (all players scored this round)
  // A round is complete when currentPlayerIndex wraps back to 0
  if (gs.currentPlayerIndex === 0) {
    gs.round += 1
  }

  // Check game end (13 rounds complete)
  if (gs.round > 13) {
    endGame(room)
    return
  }

  // Reset for next turn
  gs.rollsRemaining = 3
  gs.keptDice = [false, false, false, false, false]
  gs.phase = 'rolling'
  gs.turnStartedAt = Date.now()

  startTurnTimer(room.id)
}
```

8. **endGame and scoring:**
```javascript
function endGame(room) {
  const gs = room.gameState
  gs.phase = 'ended'
  clearTurnTimer(room.id)
  room.status = 'ended'

  // Calculate final scores
  let highestScore = -1
  let winnerId = null
  for (const player of gs.players) {
    const total = calculateTotalScoreServer(player.scoresheet)
    player.totalScore = total
    if (total > highestScore) {
      highestScore = total
      winnerId = player.userId
    }
  }
  gs.winner = winnerId

  const winnerName = gs.players.find(p => p.userId === winnerId)?.displayName
  sendSystemMessage(room.id, `Spiel beendet! Gewinner: ${winnerName} (${highestScore} Punkte)`)

  // Initialize rematch voting
  room.rematchVotes = { votedYes: [], votedNo: [], total: gs.players.length, required: Math.ceil(gs.players.length / 2) }

  io.to(room.id).emit('game:ended', { winner: winnerId, scores: gs.players.map(p => ({ userId: p.userId, displayName: p.displayName, total: p.totalScore })) })
  io.emit('room:list-update', roomManager.getPublicRooms())
}
```

9. **AFK kick:**
```javascript
function kickPlayerAFK(room, roomId, player) {
  sendSystemMessage(roomId, `${player.displayName} wurde entfernt (AFK)`)
  room.gameState.players = room.gameState.players.filter(p => p.userId !== player.userId)
  room.players = room.players.filter(p => p.userId !== player.userId)

  // If only 1 player left, end game (they win by default)
  if (room.gameState.players.length < 2) {
    endGame(room)
    return
  }

  // Adjust currentPlayerIndex if needed
  if (room.gameState.currentPlayerIndex >= room.gameState.players.length) {
    room.gameState.currentPlayerIndex = 0
  }

  io.to(roomId).emit('room:player-kicked', { userId: player.userId, reason: 'AFK' })
}
```

10. **Rematch voting:**
```javascript
socket.on('game:rematch-vote', ({ roomId, vote }, callback) => {
  const room = roomManager.getRoom(roomId)
  if (!room || !room.rematchVotes) { callback?.({ error: 'No vote active' }); return }

  const rv = room.rematchVotes
  // Remove existing vote
  rv.votedYes = rv.votedYes.filter(id => id !== socket.data.userId)
  rv.votedNo = rv.votedNo.filter(id => id !== socket.data.userId)

  if (vote) rv.votedYes.push(socket.data.userId)
  else rv.votedNo.push(socket.data.userId)

  io.to(roomId).emit('game:rematch-update', rv)

  // Check if majority voted yes
  if (rv.votedYes.length >= rv.required) {
    // Start new game
    room.status = 'waiting'
    room.gameState = null
    room.rematchVotes = null
    for (const p of room.players) { p.isReady = false }
    io.to(roomId).emit('game:rematch-accepted')
    sendSystemMessage(roomId, 'Noch eine Runde! Alle bereit machen...')
    io.emit('room:list-update', roomManager.getPublicRooms())
  } else if (rv.votedNo.length > rv.total - rv.required) {
    // Majority cannot be reached, decline
    io.to(roomId).emit('game:rematch-declined')
    sendSystemMessage(roomId, 'Kein Rematch. Zurueck zur Lobby.')
  }

  callback?.({ success: true })
})
```

11. Include inline scoring functions in server.js (simplified JS versions):
- calculateScoreServer(category, dice) -> number
- calculateTotalScoreServer(scoresheet) -> number (sum + upper bonus)
- getAllCategories() -> string[]
- getCategoryName(category) -> string (German name for system messages)

These duplicate the logic from kniffel-rules.ts but in plain JS for server.js. This is acceptable for MVP. In future, could compile TS or use a shared JS module.

12. Import randomInt at the top of server.js:
```javascript
import { randomInt } from 'node:crypto'
```
  </action>
  <verify>
`node --check server.js` passes (syntax check).
Server handles: game:start, game:player-ready, game:roll-dice, game:choose-category, game:rematch-vote.
Turn timer, auto-play, AFK detection, game end logic all present.
  </verify>
  <done>
Complete server-side game loop: start -> roll -> score -> advance turn -> end game.
Turn timers with auto-play (greedy best category) on timeout.
AFK detection kicks players after threshold consecutive inactive rounds.
Rematch voting with majority acceptance.
All dice rolls use crypto.randomInt (SPIEL-07 compliance).
System messages for all game events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build GameResults and RematchVote components</name>
  <files>
    src/components/game/GameResults.tsx
    src/components/game/RematchVote.tsx
  </files>
  <action>
Create src/components/game/GameResults.tsx ('use client'):

End-of-game results screen showing:
1. Winner announcement with trophy icon and "Gewinner: {name}" text
2. Final standings table: rank, player name, total score, upper bonus indicator
3. Detailed scoresheet: expand to see full category-by-category breakdown for all players
4. Smooth transition from game board to results

Layout:
- Large trophy/celebration animation area at top
- Podium-style ranking (1st gold, 2nd silver, 3rd bronze)
- Scores table below with all players ranked by total score
- "Noch eine Runde?" section at bottom (RematchVote)

Props:
```typescript
interface GameResultsProps {
  players: Array<{ userId: string; displayName: string; totalScore: number; scoresheet: KniffelScoresheet }>
  winnerId: string | null
  currentUserId: string
}
```

Create src/components/game/RematchVote.tsx ('use client'):

Post-game rematch voting component:
1. "Noch eine Runde?" title
2. Two buttons: "Ja, nochmal!" (green) and "Nein, danke" (gray)
3. Progress indicator: "{votedYes}/{required} stimmen fuer Rematch"
4. List of who voted (names with check/X icons)
5. "Zurueck zur Lobby" link for players who decline
6. Auto-navigate to lobby if rematch declined, or reset to waiting room if accepted

Socket events:
- Listen: 'game:rematch-update' -> update vote counts
- Listen: 'game:rematch-accepted' -> transition to waiting room
- Listen: 'game:rematch-declined' -> navigate to lobby
- Emit: 'game:rematch-vote' with { roomId, vote: boolean }

Props:
```typescript
interface RematchVoteProps {
  roomId: string
  socket: Socket
  rematchVotes: RematchVote
  currentUserId: string
}
```
  </action>
  <verify>
`npx tsc --noEmit` passes.
`npm run build` passes.
GameResults and RematchVote export correctly.
  </verify>
  <done>
GameResults shows winner, rankings, final scores with detailed scoresheet breakdown.
RematchVote enables "Noch eine Runde?" voting with majority threshold.
Rematch accepted -> back to waiting room. Declined -> back to lobby.
All German translations used.
  </done>
</task>

</tasks>

<verification>
- `node --check server.js` passes
- `npm run build` passes
- Server processes complete game loop: start -> roll -> score -> advance -> end
- Auto-play triggers on turn timeout
- AFK kick after threshold inactive rounds
- Rematch voting with majority logic
- GameResults displays winner and scores
- RematchVote enables post-game voting
</verification>

<success_criteria>
- Full game loop works server-side: 13 rounds of turns with dice rolls and category scoring
- All dice values generated via crypto.randomInt (server-authoritative)
- Turn timer auto-plays on timeout with greedy category selection
- AFK players kicked after consecutive inactive threshold
- Game ends with winner determination
- Rematch voting with majority acceptance resets to waiting room
- Results screen shows rankings and detailed scores
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-engine/02-09-SUMMARY.md`
</output>
