---
phase: 02-core-game-engine
plan: 08
type: execute
wave: 3
depends_on: ["02-03", "02-04"]
files_modified:
  - server.js
  - src/components/game/GameChat.tsx
  - src/components/game/SpectatorBanner.tsx
autonomous: true

must_haves:
  truths:
    - "Players can send and receive text messages in game room"
    - "System messages appear inline for game events"
    - "Chat is a collapsible drawer that doesn't obstruct gameplay"
    - "Spectators can read and write chat messages"
    - "Spectators see game state but cannot interact with dice or scoresheet"
  artifacts:
    - path: "src/components/game/GameChat.tsx"
      provides: "Collapsible chat drawer with message list and input"
      exports: ["GameChat"]
      min_lines: 60
    - path: "src/components/game/SpectatorBanner.tsx"
      provides: "Banner shown to spectators indicating view-only mode"
      exports: ["SpectatorBanner"]
    - path: "server.js"
      provides: "Socket.IO chat event handlers"
      contains: "chat:send"
  key_links:
    - from: "src/components/game/GameChat.tsx"
      to: "Socket.IO chat events"
      via: "emit chat:send, listen chat:message"
      pattern: "chat:send|chat:message"
    - from: "server.js"
      to: "Socket.IO rooms"
      via: "io.to(roomId).emit for chat broadcast"
      pattern: "io\\.to.*chat:message"
---

<objective>
Implement table chat and spectator mode for game rooms.

Purpose: Chat creates the "Stammtisch" atmosphere -- players and spectators can communicate during games. System messages keep everyone informed about game events. Spectator mode lets late arrivals watch and participate in chat while waiting for next round.
Output: GameChat drawer component, SpectatorBanner, server-side chat handlers, system message broadcasting.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-game-engine/02-CONTEXT.md
@server.js
@src/types/game.ts
@src/messages/de.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add chat and spectator Socket.IO handlers to server.js</name>
  <files>server.js</files>
  <action>
Add chat event handlers to server.js inside the io.on('connection') block:

1. **chat:send** - Player/spectator sends a message:
```javascript
socket.on('chat:send', ({ roomId, content }, callback) => {
  const room = roomManager.getRoom(roomId)
  if (!room) { callback?.({ error: 'Room not found' }); return }

  // Verify user is in room (player or spectator)
  const isInRoom = room.players.some(p => p.userId === socket.data.userId)
    || room.spectators.includes(socket.data.userId)
  if (!isInRoom) { callback?.({ error: 'Not in room' }); return }

  // Sanitize content (trim, max 500 chars, no empty)
  const sanitized = content?.trim().slice(0, 500)
  if (!sanitized) { callback?.({ error: 'Empty message' }); return }

  const message = {
    id: crypto.randomUUID(),
    roomId,
    userId: socket.data.userId,
    displayName: socket.data.displayName,
    content: sanitized,
    isSystem: false,
    timestamp: Date.now()
  }

  // Store in room chat history (keep last 100 messages)
  room.chat.push(message)
  if (room.chat.length > 100) room.chat.shift()

  // Broadcast to room
  io.to(roomId).emit('chat:message', message)
  callback?.({ success: true })
})
```

2. **chat:history** - Request chat history when joining room:
```javascript
socket.on('chat:history', ({ roomId }, callback) => {
  const room = roomManager.getRoom(roomId)
  if (!room) { callback?.([]); return }
  callback?.(room.chat || [])
})
```

3. **System message helper** - Add a helper function for broadcasting system messages:
```javascript
function sendSystemMessage(roomId, content) {
  const room = roomManager.getRoom(roomId)
  if (!room) return

  const message = {
    id: crypto.randomUUID(),
    roomId,
    userId: 'system',
    displayName: 'System',
    content,
    isSystem: true,
    timestamp: Date.now()
  }

  room.chat.push(message)
  if (room.chat.length > 100) room.chat.shift()
  io.to(roomId).emit('chat:message', message)
}
```

4. Add system messages to existing room events:
   - On room:join: `sendSystemMessage(roomId, '{displayName} ist beigetreten')`
   - On room:leave / disconnect: `sendSystemMessage(roomId, '{displayName} hat den Raum verlassen')`
   - On room:kick: `sendSystemMessage(roomId, '{displayName} wurde entfernt')`

5. Ensure the room.chat array is initialized in RoomManager.createRoom (already has `chat: []`).

6. For spectator handling, ensure the room:join handler already handles `status === 'playing'` case by adding to spectators array (this was added in Plan 02-04). Verify that spectators can use chat:send (the check above includes spectators).
  </action>
  <verify>
`node --check server.js` passes.
Chat handlers registered: chat:send, chat:history.
System message function exists and is called on join/leave/kick.
  </verify>
  <done>
Server handles chat:send with message validation (500 char limit, trim, non-empty).
Chat history stored per room (last 100 messages).
System messages broadcast for player join/leave/kick events.
Spectators can send and receive chat messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build GameChat drawer and SpectatorBanner components</name>
  <files>
    src/components/game/GameChat.tsx
    src/components/game/SpectatorBanner.tsx
  </files>
  <action>
Create src/components/game/GameChat.tsx ('use client'):

Collapsible bottom drawer for in-game chat:

1. **Collapsed state** (default): Small bar at bottom showing "Chat" label + unread message count badge + expand button
2. **Expanded state**: Drawer slides up from bottom, ~40% screen height on mobile, ~300px on desktop

Layout when expanded:
- Header: "Chat" title + collapse button (chevron down)
- Message list (scrollable):
  - User messages: "{displayName}: {content}" with timestamp
  - System messages: italic, muted color, e.g., "Max ist beigetreten"
  - Auto-scroll to bottom on new message
  - Show time for each message (HH:MM format)
- Input area: Text input + send button
  - Enter key sends message
  - Max 500 characters
  - Disabled if socket not connected

Unread tracking:
- When collapsed, count messages received since last collapse
- Show badge count on collapsed bar
- Reset count when expanded

On mount:
- Emit 'chat:history' to load existing messages
- Listen for 'chat:message' for new messages

On send:
- Emit 'chat:send' with { roomId, content }
- Clear input on success
- Show toast on error

Props:
```typescript
interface GameChatProps {
  roomId: string
  socket: Socket
  currentUserId: string
}
```

Use shadcn Sheet component (or custom drawer) for the sliding panel.

Create src/components/game/SpectatorBanner.tsx ('use client'):

A fixed banner at the top of the game room for spectators:
- Yellow/amber background with eye icon
- Text: "Du schaust zu" (from de.json game.spectating)
- Small text: "Du kannst in der naechsten Runde mitspielen"
- Dismiss button (X) to hide banner (stays hidden for session)

Props:
```typescript
interface SpectatorBannerProps {
  isSpectator: boolean
}
```
  </action>
  <verify>
`npx tsc --noEmit` passes.
`npm run build` passes.
GameChat exports correctly with all required functionality.
SpectatorBanner renders conditionally for spectators.
  </verify>
  <done>
GameChat is a collapsible bottom drawer with message history, real-time updates, unread badge, system messages inline.
SpectatorBanner shows "Du schaust zu" for spectators with dismiss option.
Chat messages sent via Socket.IO with 500-char limit.
All German translations used.
  </done>
</task>

</tasks>

<verification>
- `npm run build` passes
- Server handles chat:send and chat:history
- System messages broadcast on game events
- GameChat renders as collapsible drawer
- Unread message badge works
- SpectatorBanner shows for spectators only
- Messages limited to 500 chars
- Chat history loaded on room join
</verification>

<success_criteria>
- Chat messages appear in real-time for all room members
- System messages show for game events (join, leave, kick)
- Chat drawer doesn't obstruct gameplay (collapsible)
- Spectators can read and send messages
- SpectatorBanner clearly indicates view-only mode
- 100 message history limit per room
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-engine/02-08-SUMMARY.md`
</output>
