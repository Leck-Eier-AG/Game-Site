---
phase: 02-core-game-engine
plan: 05
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/components/3d/DiceScene.tsx
  - src/components/3d/Die.tsx
  - src/components/3d/DiceTable.tsx
autonomous: true

must_haves:
  truths:
    - "User sees five dice with realistic tumbling animation when rolled"
    - "User sees dice bounce and settle on a green felt surface"
    - "Each die clearly shows the correct number after settling"
    - "User can visually distinguish kept dice from rollable dice"
    - "Roll animation completes within 3 seconds with skip option available"
  artifacts:
    - path: "src/components/3d/DiceScene.tsx"
      provides: "R3F Canvas wrapper with physics world"
      exports: ["DiceScene"]
      min_lines: 40
    - path: "src/components/3d/Die.tsx"
      provides: "Individual die mesh with face textures and physics"
      exports: ["Die"]
      min_lines: 60
    - path: "src/components/3d/DiceTable.tsx"
      provides: "Static table surface for dice to land on"
      exports: ["DiceTable"]
  key_links:
    - from: "src/components/3d/DiceScene.tsx"
      to: "@react-three/fiber"
      via: "Canvas component"
      pattern: "import.*Canvas.*@react-three/fiber"
    - from: "src/components/3d/Die.tsx"
      to: "@react-three/rapier"
      via: "RigidBody for physics simulation"
      pattern: "import.*RigidBody.*@react-three/rapier"
---

<objective>
Build the 3D dice rendering system using React Three Fiber and Rapier physics.

Purpose: 3D dice are a core immersion feature ("should feel physical and satisfying" per CONTEXT.md). This plan creates reusable dice components that the game page will integrate. Building dice separately allows focused work on physics, animation, and visual quality without game logic complexity.
Output: DiceScene.tsx (Canvas + Physics wrapper), Die.tsx (individual die with faces and physics), DiceTable.tsx (surface).
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-game-engine/02-RESEARCH.md
@src/types/game.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Die component with physics and face rendering</name>
  <files>
    src/components/3d/Die.tsx
    src/components/3d/DiceTable.tsx
  </files>
  <action>
Create src/components/3d/Die.tsx - a single 3D die with:

1. **Geometry:** Rounded box (use drei's RoundedBox or standard BoxGeometry with beveled edges). Size approximately 1x1x1 unit.

2. **Face rendering:** Each face of the die needs to show the correct number (1-6). Approach: Use canvas textures or decals.
   - Create a helper function that generates a CanvasTexture for each die face (1-6 dots on white background with dark dots)
   - Use useMemo to cache textures per face value
   - Apply correct face textures to each side of the box using a multi-material approach (array of 6 materials, one per face)
   - Standard die face layout: 1 opposite 6, 2 opposite 5, 3 opposite 4

3. **Physics:** Wrap in RigidBody from @react-three/rapier
   - Use "dynamic" type for rolling dice, "kinematicPosition" for kept dice
   - On roll: apply random impulse and torque for tumbling effect
   - On keep: transition to fixed position (no physics)
   - Use onSleep callback to detect when die has stopped moving

4. **Rolling animation:**
   - Accept `isRolling` prop: when true, apply impulse to start rolling
   - Accept `targetValue` prop: the server-determined dice value (1-6)
   - After physics settle (onSleep), snap rotation to show correct `targetValue` face up
   - Total animation should take 2-3 seconds max

5. **Keep state:**
   - Accept `isKept` prop: when true, die is visually distinct
   - Kept dice: slight green glow/outline, positioned above table in a "held" area
   - Kept dice don't participate in physics (kinematic)
   - Accept `onClick` prop for toggling keep state

6. **Resource cleanup:** Dispose geometries, materials, textures in useEffect cleanup to prevent memory leaks (PITFALL 2 from research).

Props interface:
```typescript
interface DieProps {
  value: DiceValue  // 1-6, the final value to show
  index: number     // 0-4, position in the row
  isKept: boolean
  isRolling: boolean
  onClick?: () => void  // toggle keep
  disabled?: boolean    // can't click during opponent's turn
}
```

Create src/components/3d/DiceTable.tsx - the surface dice land on:
- A flat green (casino felt) rectangular surface
- Use RigidBody type="fixed" so dice collide with it
- Subtle texture or color matching the app's green accent (hsl 142 70% 45%)
- Walls/bumpers around edges to keep dice on table (invisible or subtle)
  </action>
  <verify>
`npx tsc --noEmit` passes - no type errors in 3D components.
Components import from @react-three/fiber, @react-three/rapier, and three without errors.
  </verify>
  <done>
Die.tsx renders a 3D die with correct face values, physics simulation (rolling with impulse/torque), kept state visual distinction (green glow), onClick for keep toggle, and proper resource cleanup.
DiceTable.tsx renders a green felt surface with physics collider for dice to land on.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DiceScene wrapper with Canvas and Physics</name>
  <files>src/components/3d/DiceScene.tsx</files>
  <action>
Create src/components/3d/DiceScene.tsx that wraps 5 Die components in a R3F Canvas with Rapier Physics:

```typescript
'use client'

interface DiceSceneProps {
  dice: DiceValue[]          // 5 values from server
  keptDice: boolean[]        // which are kept
  isRolling: boolean         // animation in progress
  onDieClick?: (index: number) => void  // toggle keep
  onRollComplete?: () => void  // all dice settled
  disabled?: boolean          // not player's turn
  canKeep?: boolean          // false on first roll before rolling
}
```

Implementation:
1. Wrap in `<Canvas>` with camera positioned above and slightly angled (like looking down at a table)
   - camera={{ position: [0, 8, 6], fov: 50 }}
   - Set dpr={[1, 2]} for performance on mobile

2. Inside Canvas, add `<Physics gravity={[0, -30, 0]}>` (stronger gravity for snappier dice)

3. Render 5 Die components spaced horizontally
   - Positions: dice spaced about 1.5 units apart, centered
   - Kept dice elevated slightly above the table surface

4. Lighting:
   - ambientLight intensity 0.4
   - directionalLight from above-right with shadows
   - Optional: subtle point light for atmosphere

5. onRollComplete logic:
   - Track how many dice have settled (via onSleep from each Die)
   - When all non-kept dice have settled, call onRollComplete

6. "Skip animation" support:
   - Accept an imperative ref or callback pattern that lets parent instantly settle all dice
   - OR: simply set a timeout (3s max) after which dice snap to final positions

7. IMPORTANT: This component must be 'use client' and wrapped in dynamic import with ssr: false when used in a page, because R3F requires browser APIs (WebGL). Add a comment noting this.

8. Add a Suspense fallback with a loading spinner inside the Canvas using drei's Html component.

9. Performance: Use `<AdaptiveDpr pixelated />` from @react-three/drei for mobile performance.
  </action>
  <verify>
`npx tsc --noEmit` passes.
DiceScene.tsx exports DiceScene component with correct props.
No direct DOM manipulation (all through R3F declarative API).
  </verify>
  <done>
DiceScene.tsx provides a complete 3D dice rolling experience: 5 dice on a green felt table, physics-based rolling animation, keep/release interaction, roll completion detection, skip animation support, and mobile-optimized rendering.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes for all 3D components
- DiceScene, Die, DiceTable all export correctly
- Components use 'use client' directive
- Physics imports from @react-three/rapier
- Canvas from @react-three/fiber
- Resource cleanup in useEffect returns
- No server-side code in components (all client-side)
</verification>

<success_criteria>
- Three component files exist: DiceScene.tsx, Die.tsx, DiceTable.tsx
- Die renders correct face value for each number 1-6
- Physics simulation makes dice tumble and bounce
- Kept dice are visually distinct (glow/elevation)
- DiceScene manages 5 dice with keep/roll interaction
- Performance considerations: dpr capping, Suspense fallback
- Memory leak prevention: resource disposal in cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-engine/02-05-SUMMARY.md`
</output>
