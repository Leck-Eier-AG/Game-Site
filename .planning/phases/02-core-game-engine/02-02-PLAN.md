---
phase: 02-core-game-engine
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/game/kniffel-rules.ts
  - src/lib/game/__tests__/kniffel-rules.test.ts
  - package.json
  - jest.config.ts
  - tsconfig.json
autonomous: true

must_haves:
  truths:
    - "Kniffel scoring calculates correct points for all 13 categories"
    - "Upper section bonus (35 points) awards when sum >= 63"
    - "Straights, full house, and Kniffel detection work correctly"
    - "Available categories correctly identified from scoresheet state"
    - "Auto-play selects the highest-scoring available category"
  artifacts:
    - path: "src/lib/game/kniffel-rules.ts"
      provides: "Scoring algorithms, category validation, auto-play"
      exports: ["calculateScore", "getAvailableCategories", "calculateUpperBonus", "autoPickCategory", "calculateTotalScore"]
    - path: "src/lib/game/__tests__/kniffel-rules.test.ts"
      provides: "Comprehensive test suite for scoring"
      min_lines: 100
  key_links:
    - from: "src/lib/game/kniffel-rules.ts"
      to: "src/types/game.ts"
      via: "imports ScoreCategory, DiceValues, KniffelScoresheet"
      pattern: "import.*from.*types/game"
---

<objective>
Implement and test the Kniffel scoring algorithm using TDD (Red-Green-Refactor).

Purpose: Kniffel scoring has many edge cases (bonus rules, straight detection, full house validation). TDD ensures correctness before integration with game logic. This is pure business logic with defined inputs/outputs -- ideal for TDD.
Output: Fully tested kniffel-rules.ts with calculateScore, getAvailableCategories, autoPickCategory, and calculateTotalScore.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-game-engine/02-RESEARCH.md
</context>

<feature>
  <name>Kniffel Scoring Algorithm</name>
  <files>src/lib/game/kniffel-rules.ts, src/lib/game/__tests__/kniffel-rules.test.ts</files>
  <behavior>
    calculateScore(category, dice) -> number:
    - ones([1,1,3,4,5]) -> 2
    - twos([2,2,2,1,3]) -> 6
    - threes([3,3,3,3,1]) -> 12
    - fours([4,4,4,4,4]) -> 20
    - fives([5,5,1,2,3]) -> 10
    - sixes([6,6,6,1,2]) -> 18
    - threeOfKind([3,3,3,2,1]) -> 12 (sum of all)
    - threeOfKind([1,2,3,4,5]) -> 0 (no three of kind)
    - fourOfKind([4,4,4,4,2]) -> 18 (sum of all)
    - fourOfKind([3,3,3,2,1]) -> 0 (only three, not four)
    - fullHouse([3,3,3,2,2]) -> 25
    - fullHouse([3,3,3,3,2]) -> 0 (four of kind, not full house)
    - fullHouse([1,1,1,1,1]) -> 0 (five of kind, not full house)
    - smallStraight([1,2,3,4,6]) -> 30
    - smallStraight([2,3,4,5,5]) -> 30
    - smallStraight([3,4,5,6,1]) -> 30
    - smallStraight([1,2,4,5,6]) -> 0
    - largeStraight([1,2,3,4,5]) -> 40
    - largeStraight([2,3,4,5,6]) -> 40
    - largeStraight([1,2,3,4,6]) -> 0
    - kniffel([5,5,5,5,5]) -> 50
    - kniffel([5,5,5,5,4]) -> 0
    - chance([1,2,3,4,5]) -> 15 (sum of all)

    calculateUpperBonus(scoresheet) -> number:
    - Sum of ones-sixes >= 63 -> 35
    - Sum of ones-sixes < 63 -> 0

    getAvailableCategories(scoresheet) -> ScoreCategory[]:
    - Empty scoresheet -> all 13 categories
    - Scoresheet with ones=3, twos=6 -> 11 remaining categories

    autoPickCategory(dice, scoresheet) -> ScoreCategory:
    - Picks category yielding highest score from available categories
    - If tie, prefer lower section categories (higher value)

    calculateTotalScore(scoresheet) -> number:
    - Sums all filled categories + upper bonus if applicable
  </behavior>
  <implementation>
First set up Jest testing infrastructure if not already present:
- Install jest, ts-jest, @types/jest as dev dependencies
- Create jest.config.ts with ts-jest preset and moduleNameMapper for @/ alias
- Add "test" script to package.json

Note: The types referenced (ScoreCategory, DiceValues, KniffelScoresheet) will be created by Plan 02-01. Since Plan 02 runs in parallel (Wave 1), define the needed types locally in kniffel-rules.ts if types/game.ts doesn't exist yet, OR import them if Plan 01 completed first. The executor should check if types/game.ts exists and import from there; if not, define minimal inline types and refactor later.

Implement scoring using dice frequency counting approach:
- Build counts array: counts[1..6] = how many of each value
- Upper section: counts[n] * n
- Three/four of kind: check if any count >= 3/4, return sum
- Full house: exactly one count of 3 AND one count of 2 (NOT five of kind)
- Small straight: check for [1,2,3,4], [2,3,4,5], or [3,4,5,6] subsequence
- Large straight: check for [1,2,3,4,5] or [2,3,4,5,6]
- Kniffel: any count === 5
- Chance: sum of all dice

Important edge cases:
- Full house must have exactly 3+2, not 5 of same kind
- Four of a kind with [4,4,4,4,4] should return sum (not 0)
- Small straight detection must handle duplicates: [1,2,3,4,4] is valid
  </implementation>
</feature>

<verification>
- `npm test -- --testPathPattern=kniffel-rules` passes all tests
- All 13 scoring categories tested with positive and negative cases
- Upper bonus logic tested
- Auto-play algorithm tested
- Edge cases (five of kind for full house, duplicates in straights) covered
</verification>

<success_criteria>
- kniffel-rules.ts exports: calculateScore, getAvailableCategories, calculateUpperBonus, autoPickCategory, calculateTotalScore
- Test file has 15+ test cases covering all categories and edge cases
- All tests pass
- No type errors in tsc --noEmit
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-engine/02-02-SUMMARY.md`
</output>
