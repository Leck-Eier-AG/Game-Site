---
phase: 02-core-game-engine
plan: 07
type: execute
wave: 3
depends_on: ["02-03", "02-04", "02-05"]
files_modified:
  - src/app/game/[roomId]/page.tsx
  - src/components/game/GameBoard.tsx
  - src/components/game/Scoresheet.tsx
  - src/components/game/TurnTimer.tsx
  - src/components/game/PlayerList.tsx
  - src/components/game/WaitingRoom.tsx
autonomous: true

must_haves:
  truths:
    - "Game room page loads for a specific room and connects via Socket.IO"
    - "Waiting room shows players with ready-up buttons before game starts"
    - "During game, dice scene and scoresheet are both visible"
    - "Turn timer counts down and shows whose turn it is"
    - "Player can select a scoring category after rolling"
    - "Scoresheet shows all players' scores in full table view"
  artifacts:
    - path: "src/app/game/[roomId]/page.tsx"
      provides: "Game room route with dynamic roomId"
      min_lines: 30
    - path: "src/components/game/GameBoard.tsx"
      provides: "Main game layout combining dice, scoresheet, timer"
      exports: ["GameBoard"]
      min_lines: 80
    - path: "src/components/game/Scoresheet.tsx"
      provides: "Kniffel scoresheet with category selection"
      exports: ["Scoresheet"]
      min_lines: 60
    - path: "src/components/game/TurnTimer.tsx"
      provides: "Visual countdown timer"
      exports: ["TurnTimer"]
    - path: "src/components/game/WaitingRoom.tsx"
      provides: "Pre-game lobby with ready-up and host controls"
      exports: ["WaitingRoom"]
  key_links:
    - from: "src/components/game/GameBoard.tsx"
      to: "src/components/3d/DiceScene.tsx"
      via: "renders DiceScene with game state dice values"
      pattern: "import.*DiceScene"
    - from: "src/components/game/GameBoard.tsx"
      to: "Socket.IO game events"
      via: "emits game:roll-dice, game:choose-category"
      pattern: "game:roll-dice|game:choose-category"
    - from: "src/components/game/GameBoard.tsx"
      to: "DiceScene.onRollComplete"
      via: "onRollComplete callback enables category selection UI after animation"
      pattern: "onRollComplete"
    - from: "src/components/game/Scoresheet.tsx"
      to: "src/lib/game/kniffel-rules.ts"
      via: "shows potential scores using calculateScore"
      pattern: "import.*calculateScore"
---

<objective>
Build the game room page with waiting room, game board (dice + scoresheet + timer), and player list.

Purpose: This is the core gameplay experience -- where players actually play Kniffel. It combines the 3D dice scene, scoresheet, turn timer, and real-time state updates into a cohesive game interface. Also includes the pre-game waiting room with ready-up and host controls.
Output: /game/[roomId] page with WaitingRoom, GameBoard (DiceScene + Scoresheet + TurnTimer), PlayerList.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-game-engine/02-CONTEXT.md
@.planning/phases/02-core-game-engine/02-RESEARCH.md
@src/lib/socket/provider.tsx
@src/types/game.ts
@src/messages/de.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create game room page with waiting room and player list</name>
  <files>
    src/app/game/[roomId]/page.tsx
    src/components/game/WaitingRoom.tsx
    src/components/game/PlayerList.tsx
  </files>
  <action>
Create src/app/game/[roomId]/page.tsx:

This is a client component ('use client') since it needs Socket.IO. It must be dynamically rendered (not statically generated).

Implementation:
1. Extract roomId from params (Next.js dynamic route)
2. Use useSocket() to get socket connection
3. On mount, emit 'room:join' with roomId to join/rejoin the room
4. Listen for 'game:state-update' events to receive game state
5. Listen for 'room:player-joined', 'room:player-left' events
6. Store game room state in useState
7. Conditionally render:
   - If room.status === 'waiting': show WaitingRoom
   - If room.status === 'playing': show GameBoard (dynamically imported with ssr: false for R3F)
   - If room.status === 'ended': show game results
8. Handle leaving room: emit 'room:leave' on unmount (useEffect cleanup)
9. Handle errors: room not found, kicked, etc.

Import DiceScene dynamically:
```typescript
import dynamic from 'next/dynamic'
const GameBoard = dynamic(() => import('@/components/game/GameBoard').then(m => m.GameBoard), { ssr: false })
```

Create src/components/game/WaitingRoom.tsx ('use client'):

Pre-game lobby showing:
1. Room name and settings (max players, turn timer, AFK threshold)
2. Player list with ready status (green check / gray X)
3. "Bereit" toggle button for current player
4. Host controls (only shown to host):
   - "Spiel starten" button (enabled when all players ready, min 2)
   - "Spiel erzwingen" button (force-start with ready players only)
   - Kick player buttons next to each non-host player
5. Room link to share (copy to clipboard button for private rooms)
6. Spectator count if any

Socket events emitted:
- 'game:player-ready' when toggling ready state
- 'game:start' when host clicks start (server validates all ready)
- 'room:kick' when host kicks player

Props:
```typescript
interface WaitingRoomProps {
  room: RoomData  // full room object from server
  currentUserId: string
  socket: Socket
}
```

Create src/components/game/PlayerList.tsx ('use client'):

Compact player list shown during gameplay (sidebar or top bar):
- Player avatars/initials in a row
- Current player highlighted (green border)
- Score for each player (running total)
- Connection status indicator (green dot = connected)
- Spectator count
  </action>
  <verify>
`npm run build` passes.
Page route /game/[roomId] resolves correctly.
WaitingRoom renders with player list and ready-up button.
  </verify>
  <done>
Game room page at /game/[roomId] connects to room via Socket.IO.
Waiting room shows players, ready-up, host controls, room settings.
Player list shows during gameplay with scores and turn indicator.
Dynamic import for GameBoard prevents SSR issues with R3F.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build GameBoard, Scoresheet, and TurnTimer</name>
  <files>
    src/components/game/GameBoard.tsx
    src/components/game/Scoresheet.tsx
    src/components/game/TurnTimer.tsx
  </files>
  <action>
Create src/components/game/GameBoard.tsx ('use client'):

Main game interface combining all game elements. Layout:
- Top: PlayerList (horizontal, showing all players with current turn indicator)
- Middle-left: DiceScene (3D dice area, takes ~60% width on desktop)
- Middle-right: Scoresheet (takes ~40% width on desktop)
- Bottom: TurnTimer bar + action buttons (Roll / Score)
- Mobile: Stack vertically (dice on top, scoresheet below, timer fixed at bottom)

**CRITICAL: Dice roll flow (Roll button -> DiceScene -> Socket):**

The dice rolling flow works as follows:
1. Current player clicks the "Wuerfeln" button.
2. GameBoard immediately emits `socket.emit('game:roll-dice', { roomId, keptDice })` to the server. The server generates new dice values via crypto RNG and broadcasts `game:state-update` with the new dice values back.
3. When the new `game:state-update` arrives with changed dice values, GameBoard sets `isRolling=true` on DiceScene and passes the new server-determined dice values as `dice` prop.
4. DiceScene animates the physics-based tumbling, then snaps each die to show the correct server-determined face value.
5. When all dice settle, DiceScene calls `onRollComplete` callback.
6. In the `onRollComplete` handler, GameBoard sets `isRolling=false` and enables the category selection UI on the Scoresheet. While dice are animating (`isRolling=true`), scoresheet category clicks should be disabled.

This means GameBoard needs local state:
- `isAnimating: boolean` -- true while DiceScene is playing roll animation
- Set to `true` when new dice values arrive from server (different from previous)
- Set to `false` when DiceScene calls `onRollComplete`
- Scoresheet `canScore` prop is: `isMyTurn && rollsRemaining < 3 && !isAnimating`

State management:
- Receive gameState from parent (page component) via props
- Current player's actions:
  * "Wuerfeln" button: emit 'game:roll-dice' with keptDice array. Disabled if not your turn, rollsRemaining === 0, or isAnimating
  * Clicking scoresheet category: emit 'game:choose-category' with category. Only enabled after at least one roll and animation complete.
- Show "Du bist dran!" or "Warte auf {playerName}" message
- Show "Runde {n} von 13" indicator
- Show rollsRemaining counter ("{n} Wuerfe uebrig")

Socket events:
- Listen: 'game:state-update' -> update local state, trigger dice animation if dice changed
- Listen: 'game:error' -> show toast with error message
- Emit: 'game:roll-dice' with { roomId, keptDice: boolean[] }
- Emit: 'game:choose-category' with { roomId, category: ScoreCategory }

Props:
```typescript
interface GameBoardProps {
  gameState: GameState
  roomId: string
  currentUserId: string
  socket: Socket
}
```

Create src/components/game/Scoresheet.tsx ('use client'):

Kniffel scoresheet with two view modes:
1. **Compact view** (default on mobile): Own scores only, single column
2. **Full table view** (default on desktop): All players side by side

Layout:
- Upper section: Einser through Sechser + Bonus row + Upper total
- Lower section: Dreierpasch through Chance + Lower total
- Grand total row at bottom

For each category row:
- Category name (German from de.json)
- If scored: show the score number
- If available AND it's current player's turn AND dice have been rolled:
  * Show potential score (calculated via calculateScore from kniffel-rules.ts)
  * Highlight/glow the row to indicate it's clickable
  * onClick: call onSelectCategory(category)
- If not available and not scored: show dash or empty

Import calculateScore from kniffel-rules.ts to show potential scores. This gives players feedback on what they'd get for each available category with current dice.

Toggle button between compact/full view (from de.json: "Kompakt" / "Alle Spieler").

Props:
```typescript
interface ScoresheetProps {
  players: PlayerState[]
  currentPlayerIndex: number
  currentUserId: string
  dice: DiceValues
  rollsRemaining: number
  onSelectCategory: (category: ScoreCategory) => void
  canScore: boolean // true if it's player's turn, they've rolled, AND dice animation is complete
}
```

Create src/components/game/TurnTimer.tsx ('use client'):

Visual countdown timer:
1. Receive turnStartedAt (timestamp) and turnDuration (seconds) from game state
2. Calculate remaining time: duration - (Date.now() - startedAt) / 1000
3. Update every second via setInterval (cleanup in useEffect return)
4. Display:
   - Progress bar (full width, shrinks as time runs out)
   - Numeric seconds remaining
   - Color transition: green -> yellow (< 30%) -> red (< 10%)
5. At 10s remaining, show "Auto-Zug in {n}s" warning text
6. Use server timestamp for sync (PITFALL 5): don't start local timer, calculate from server's startedAt

Props:
```typescript
interface TurnTimerProps {
  startedAt: number | null  // server timestamp
  duration: number          // seconds
  isCurrentPlayer: boolean
}
```
  </action>
  <verify>
`npm run build` passes (use `npx tsc --noEmit` first for faster feedback).
GameBoard renders DiceScene and Scoresheet.
GameBoard has isAnimating state that gates scoresheet interaction.
Scoresheet shows all 13 categories with German names.
TurnTimer calculates from server timestamp.
  </verify>
  <done>
GameBoard combines DiceScene + Scoresheet + TurnTimer with responsive layout.
Roll flow fully wired: Roll button -> socket emit -> server dice -> state update -> DiceScene animation -> onRollComplete -> enable scoring.
Scoresheet shows potential scores for current dice and allows category selection only when animation is complete.
TurnTimer syncs with server timestamp and shows color-coded countdown.
All text in German using de.json translations.
  </done>
</task>

</tasks>

<verification>
- `npm run build` passes
- /game/[roomId] route works
- WaitingRoom shows players with ready-up
- GameBoard renders dice scene + scoresheet + timer
- Roll button emits game:roll-dice immediately, DiceScene animates on state update, onRollComplete enables scoring
- Scoresheet highlights available categories with potential scores
- TurnTimer calculates from server startedAt timestamp
- Socket events wired for all game actions
</verification>

<success_criteria>
- Game room page renders at /game/[roomId]
- Waiting -> Playing -> Ended transitions work via Socket.IO state updates
- Dice rolling triggers via "Wuerfeln" button -> socket emit -> server response -> DiceScene animation -> onRollComplete -> category selection enabled
- Category selection triggers via scoresheet click -> socket emit
- Turn timer shows correct remaining time synced with server
- Responsive layout: side-by-side on desktop, stacked on mobile
- All German translations applied
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-engine/02-07-SUMMARY.md`
</output>
