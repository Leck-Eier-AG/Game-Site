---
phase: 02-core-game-engine
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - server.js
  - src/lib/game/room-manager.ts
autonomous: true

must_haves:
  truths:
    - "Server creates rooms and stores them in memory with full settings"
    - "Players can join and leave rooms via Socket.IO events"
    - "Room list is broadcast to all connected clients when rooms change"
    - "Disconnected players are removed from rooms"
    - "Empty rooms are cleaned up automatically"
  artifacts:
    - path: "src/lib/game/room-manager.ts"
      provides: "In-memory room storage and lifecycle management"
      exports: ["RoomManager"]
      min_lines: 100
    - path: "server.js"
      provides: "Socket.IO event handlers for room operations"
      contains: "room:create"
  key_links:
    - from: "server.js"
      to: "src/lib/game/room-manager.ts"
      via: "imports RoomManager for room state"
      pattern: "import.*RoomManager|require.*room-manager"
    - from: "server.js"
      to: "Socket.IO rooms API"
      via: "socket.join(roomId) for room isolation"
      pattern: "socket\\.join"
---

<objective>
Implement the server-side room lifecycle: creating rooms, joining/leaving, player tracking, disconnect handling, and empty room cleanup.

Purpose: The room manager is the server-side backbone for all game interactions. It manages in-memory game state (rooms, players, spectators) and exposes Socket.IO event handlers for room operations. The lobby and game pages both depend on this.
Output: room-manager.ts class managing room state, server.js with all room Socket.IO handlers.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-game-engine/02-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md
@server.js
@src/types/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RoomManager class for in-memory room state</name>
  <files>src/lib/game/room-manager.ts</files>
  <action>
Create src/lib/game/room-manager.ts with a RoomManager class that stores rooms in a Map.

Note: This is a server-side module (runs in server.js which is plain Node.js, NOT Next.js). It will be imported via dynamic import in server.js. Use relative imports or configure the import path carefully since server.js runs outside of Next.js compilation.

Actually, since server.js is plain Node.js ES modules (type: "module" in package.json), and this file uses TypeScript types, the cleanest approach is to write room-manager as a .js file that server.js can import directly, OR keep it as .ts and have server.js import it dynamically.

Best approach: Write room-manager.ts but the server.js will use a compiled version. Since the project uses `node server.js` directly (not through Next.js), we need room-manager to be importable.

Solution: Write the room management logic directly in server.js (extending the existing file), keeping all server-side game logic in one place. This avoids module resolution issues between plain Node.js and TypeScript.

Implement in server.js (or a separate .js file that server.js imports):

```javascript
// Room Manager - in-memory room state
class RoomManager {
  constructor() {
    this.rooms = new Map() // roomId -> room object
    this.userRooms = new Map() // userId -> Set<roomId>
  }

  createRoom(hostId, hostName, settings) {
    const roomId = generateRoomId() // cuid or crypto.randomUUID()
    const room = {
      id: roomId,
      name: settings.name,
      hostId,
      hostName,
      gameType: 'kniffel',
      status: 'waiting',
      isPrivate: settings.isPrivate || false,
      maxPlayers: settings.maxPlayers || 6,
      turnTimer: settings.turnTimer || 60,
      afkThreshold: settings.afkThreshold || 3,
      players: [{ userId: hostId, displayName: hostName, isReady: false }],
      spectators: [],
      gameState: null,
      chat: [],
      createdAt: Date.now()
    }
    this.rooms.set(roomId, room)
    this._trackUser(hostId, roomId)
    return room
  }

  joinRoom(roomId, userId, displayName) {
    const room = this.rooms.get(roomId)
    if (!room) return { error: 'Room not found' }

    // Check if already in room
    if (room.players.some(p => p.userId === userId)) {
      return { room, rejoined: true }
    }

    // If game in progress, join as spectator
    if (room.status === 'playing') {
      if (!room.spectators.includes(userId)) {
        room.spectators.push(userId)
      }
      this._trackUser(userId, roomId)
      return { room, spectator: true }
    }

    if (room.players.length >= room.maxPlayers) {
      return { error: 'Room is full' }
    }

    room.players.push({ userId, displayName, isReady: false })
    this._trackUser(userId, roomId)
    return { room }
  }

  leaveRoom(roomId, userId) {
    const room = this.rooms.get(roomId)
    if (!room) return null

    room.players = room.players.filter(p => p.userId !== userId)
    room.spectators = room.spectators.filter(id => id !== userId)
    this._untrackUser(userId, roomId)

    // If host left, assign new host
    if (room.hostId === userId && room.players.length > 0) {
      room.hostId = room.players[0].userId
      room.hostName = room.players[0].displayName
    }

    // Cleanup empty room
    if (room.players.length === 0 && room.spectators.length === 0) {
      this.rooms.delete(roomId)
      return null
    }

    return room
  }

  getRoom(roomId) { return this.rooms.get(roomId) || null }

  getPublicRooms() {
    return Array.from(this.rooms.values())
      .filter(r => !r.isPrivate && r.status !== 'ended')
      .map(r => ({
        id: r.id,
        name: r.name,
        hostName: r.hostName,
        gameType: r.gameType,
        status: r.status,
        maxPlayers: r.maxPlayers,
        currentPlayers: r.players.length,
        playerNames: r.players.map(p => p.displayName),
        createdAt: r.createdAt
      }))
  }

  getUserRooms(userId) {
    const roomIds = this.userRooms.get(userId) || new Set()
    return Array.from(roomIds).map(id => this.rooms.get(id)).filter(Boolean)
  }

  removeUserFromAllRooms(userId) {
    const roomIds = this.userRooms.get(userId) || new Set()
    const affectedRooms = []
    for (const roomId of roomIds) {
      const room = this.leaveRoom(roomId, userId)
      if (room) affectedRooms.push(room)
    }
    this.userRooms.delete(userId)
    return affectedRooms
  }

  // Periodic cleanup for stale rooms
  cleanup() {
    const now = Date.now()
    const staleThreshold = 30 * 60 * 1000 // 30 min
    for (const [roomId, room] of this.rooms) {
      if (room.status === 'ended' && (now - room.createdAt) > staleThreshold) {
        this.rooms.delete(roomId)
      }
      if (room.players.length === 0 && room.spectators.length === 0) {
        this.rooms.delete(roomId)
      }
    }
  }

  _trackUser(userId, roomId) {
    if (!this.userRooms.has(userId)) this.userRooms.set(userId, new Set())
    this.userRooms.get(userId).add(roomId)
  }

  _untrackUser(userId, roomId) {
    const rooms = this.userRooms.get(userId)
    if (rooms) { rooms.delete(roomId); if (rooms.size === 0) this.userRooms.delete(userId) }
  }
}
```

Use crypto.randomUUID() for room IDs (built-in Node.js, no external dependency).
  </action>
  <verify>
File exists and contains RoomManager class with createRoom, joinRoom, leaveRoom, getRoom, getPublicRooms, removeUserFromAllRooms, cleanup methods.
  </verify>
  <done>
RoomManager class manages in-memory rooms with full CRUD operations, user tracking, host reassignment on leave, empty room cleanup, and spectator support for in-progress games.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Socket.IO room event handlers to server.js</name>
  <files>server.js</files>
  <action>
Extend server.js (which already has Socket.IO auth middleware from Phase 1) with room lifecycle event handlers. The RoomManager can be defined directly in server.js or imported from a .js file.

Add these Socket.IO event handlers inside the `io.on('connection', (socket) => { ... })` block:

1. **room:list** - Client requests room list
   ```javascript
   socket.on('room:list', (callback) => {
     callback(roomManager.getPublicRooms())
   })
   ```

2. **room:create** - Client creates a new room
   ```javascript
   socket.on('room:create', ({ settings }, callback) => {
     const room = roomManager.createRoom(socket.data.userId, socket.data.displayName, settings)
     socket.join(room.id)
     callback({ roomId: room.id, room: roomManager.getPublicRooms().find(r => r.id === room.id) })
     // Broadcast updated room list to lobby
     io.emit('room:list-update', roomManager.getPublicRooms())
   })
   ```

3. **room:join** - Client joins existing room
   ```javascript
   socket.on('room:join', ({ roomId }, callback) => {
     const result = roomManager.joinRoom(roomId, socket.data.userId, socket.data.displayName)
     if (result.error) { callback({ error: result.error }); return }
     socket.join(roomId)
     callback({ room: result.room, spectator: result.spectator || false })
     io.to(roomId).emit('room:player-joined', {
       userId: socket.data.userId,
       displayName: socket.data.displayName,
       spectator: result.spectator || false
     })
     io.emit('room:list-update', roomManager.getPublicRooms())
   })
   ```

4. **room:leave** - Client leaves room
   ```javascript
   socket.on('room:leave', ({ roomId }, callback) => {
     const room = roomManager.leaveRoom(roomId, socket.data.userId)
     socket.leave(roomId)
     if (room) {
       io.to(roomId).emit('room:player-left', { userId: socket.data.userId })
       if (room.hostId !== socket.data.userId) {
         io.to(roomId).emit('room:new-host', { hostId: room.hostId })
       }
     }
     io.emit('room:list-update', roomManager.getPublicRooms())
     callback?.({ success: true })
   })
   ```

5. **room:kick** - Host kicks a player
   ```javascript
   socket.on('room:kick', ({ roomId, targetUserId }, callback) => {
     const room = roomManager.getRoom(roomId)
     if (!room || room.hostId !== socket.data.userId) { callback?.({ error: 'Not host' }); return }
     roomManager.leaveRoom(roomId, targetUserId)
     io.to(roomId).emit('room:player-kicked', { userId: targetUserId })
     io.emit('room:list-update', roomManager.getPublicRooms())
     callback?.({ success: true })
   })
   ```

6. Update **disconnect** handler to remove user from all rooms:
   ```javascript
   socket.on('disconnect', () => {
     console.log(`Client disconnected: ${socket.data.userId}`)
     const affectedRooms = roomManager.removeUserFromAllRooms(socket.data.userId)
     for (const room of affectedRooms) {
       io.to(room.id).emit('room:player-left', { userId: socket.data.userId })
     }
     io.emit('room:list-update', roomManager.getPublicRooms())
   })
   ```

7. Add periodic cleanup interval:
   ```javascript
   setInterval(() => roomManager.cleanup(), 60000) // Every 60s
   ```

8. Important: To get displayName for the socket user, the auth middleware needs to fetch it from the database. Update the io.use() middleware to look up the user's displayName from Prisma after JWT verification:
   - Import PrismaClient at the top of server.js (dynamic import since it's a Node module)
   - After verifying JWT, query `prisma.user.findUnique({ where: { id: payload.userId }, select: { displayName: true } })`
   - Store as `socket.data.displayName`
   - Handle case where user not found (disconnect with error)

Use Prisma client in server.js:
```javascript
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()
```

Add at the top of the file alongside existing imports.

9. Update the **request-state** handler to actually send room state if user is in a room:
   ```javascript
   socket.on('request-state', () => {
     const userRooms = roomManager.getUserRooms(socket.data.userId)
     if (userRooms.length > 0) {
       const room = userRooms[0] // User's active room
       socket.emit('room:state', { room })
     }
   })
   ```
  </action>
  <verify>
Run `node --check server.js` (syntax check) - must pass without errors.
Run `npm run build` - Next.js build still passes.
  </verify>
  <done>
server.js handles: room:list, room:create, room:join, room:leave, room:kick, disconnect cleanup, periodic room cleanup.
Socket.IO rooms API used (socket.join/leave) for message isolation.
Auth middleware enriched with displayName from database.
Room list broadcast on every change for lobby real-time updates.
  </done>
</task>

</tasks>

<verification>
- `node --check server.js` passes
- `npm run build` passes
- server.js contains RoomManager with all CRUD operations
- Socket.IO handlers for room:create, room:join, room:leave, room:list, room:kick registered
- disconnect handler cleans up rooms
- Periodic cleanup interval running
</verification>

<success_criteria>
- RoomManager class in server.js with createRoom, joinRoom, leaveRoom, getRoom, getPublicRooms
- 6 Socket.IO event handlers registered (list, create, join, leave, kick, disconnect)
- Auth middleware includes displayName lookup
- Empty room cleanup on disconnect and periodic interval
- Room list broadcast on every room change
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-engine/02-04-SUMMARY.md`
</output>
