---
phase: 02-core-game-engine
plan: 03
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/game/state-machine.ts
  - src/lib/game/__tests__/state-machine.test.ts
autonomous: true

must_haves:
  truths:
    - "State machine enforces legal transitions between game phases"
    - "Only the current player can perform actions"
    - "Roll count decrements correctly and blocks at 0"
    - "Turn advances to next player after scoring"
    - "Game ends after all players complete 13 rounds"
  artifacts:
    - path: "src/lib/game/state-machine.ts"
      provides: "Game state transitions and validation"
      exports: ["createInitialState", "applyAction", "isValidAction", "advanceTurn", "checkGameEnd"]
    - path: "src/lib/game/__tests__/state-machine.test.ts"
      provides: "State machine transition tests"
      min_lines: 80
  key_links:
    - from: "src/lib/game/state-machine.ts"
      to: "src/types/game.ts"
      via: "imports GameState, GamePhase, PlayerState"
      pattern: "import.*from.*types/game"
    - from: "src/lib/game/state-machine.ts"
      to: "src/lib/game/kniffel-rules.ts"
      via: "uses calculateScore for scoring validation"
      pattern: "import.*calculateScore.*kniffel-rules"
---

<objective>
Implement and test the game state machine that manages Kniffel turn flow using TDD.

Purpose: The state machine is the brain of the game -- it enforces legal transitions (waiting -> rolling -> scoring -> next turn -> ended), validates player actions, and manages turn advancement. TDD ensures no illegal state transitions are possible, preventing cheating and desync.
Output: Fully tested state-machine.ts with createInitialState, applyAction, isValidAction, advanceTurn, checkGameEnd.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-game-engine/02-RESEARCH.md
@src/types/game.ts
</context>

<feature>
  <name>Game State Machine</name>
  <files>src/lib/game/state-machine.ts, src/lib/game/__tests__/state-machine.test.ts</files>
  <behavior>
    createInitialState(players, settings) -> GameState:
    - phase: 'waiting'
    - players array with empty scoresheets, isReady: false
    - rollsRemaining: 3, round: 1
    - dice: [1,1,1,1,1] (placeholder)

    applyAction(state, action, userId) -> GameState | Error:

    Action: PLAYER_READY
    - In 'waiting' phase, sets player.isReady = true
    - If all players ready (min 2), transition to 'rolling' phase
    - Error if not in waiting phase

    Action: ROLL_DICE (with keptDice boolean[])
    - Only current player can roll
    - Must be in 'rolling' phase (first roll transitions from waiting->rolling)
    - rollsRemaining must be > 0
    - Returns new state with rollsRemaining - 1
    - Dice values NOT set here (server sets them via crypto-rng)
    - After roll, if rollsRemaining becomes 0, phase stays 'rolling' (player must score)

    Action: CHOOSE_CATEGORY (with category: ScoreCategory)
    - Only current player can choose
    - Must be in 'rolling' phase and rollsRemaining < 3 (must have rolled at least once)
    - Category must be available (not already scored)
    - Calculates score and fills scoresheet
    - Calls advanceTurn to move to next player

    advanceTurn(state) -> GameState:
    - Advances currentPlayerIndex to next player
    - Resets rollsRemaining to 3, keptDice to all false
    - If all players completed current round, increment round
    - If round > 13, call checkGameEnd

    checkGameEnd(state) -> GameState:
    - Calculates total scores for all players
    - Sets winner to player with highest total
    - Sets phase to 'ended'

    isValidAction(state, action, userId) -> boolean:
    - Returns true if the action would succeed
    - Used for client-side UI hints (enable/disable buttons)

    Error cases:
    - applyAction('waiting', ROLL_DICE) -> Error "Not in rolling phase"
    - applyAction('rolling', ROLL_DICE, wrongUser) -> Error "Not your turn"
    - applyAction('rolling', ROLL_DICE) when rollsRemaining=0 -> Error "No rolls remaining"
    - applyAction('rolling', CHOOSE_CATEGORY, 'ones') when ones already scored -> Error "Category already scored"
    - applyAction('ended', anything) -> Error "Game is over"
  </behavior>
  <implementation>
Import types from src/types/game.ts (created by Plan 02-01). If Plan 02-02 (scoring) completed, import calculateScore from kniffel-rules.ts. If not yet available, the state machine should accept a dice->score calculation as a parameter or import it -- check for file existence and import accordingly.

The state machine is a pure function: takes state + action, returns new state or Error. No side effects, no randomness (dice values are injected by the server).

Define action types:
```typescript
type GameAction =
  | { type: 'PLAYER_READY' }
  | { type: 'ROLL_DICE'; keptDice: boolean[]; newDice: DiceValue[] }  // newDice from server
  | { type: 'CHOOSE_CATEGORY'; category: ScoreCategory }
  | { type: 'PLAYER_DISCONNECT'; userId: string }
  | { type: 'PLAYER_RECONNECT'; userId: string }
```

Note: ROLL_DICE includes newDice values because the server generates them (crypto-rng) and passes them into the state machine. The state machine does NOT generate random numbers.

Key implementation details:
- Use immutable state updates (spread operator, no mutation)
- Return Error objects (not throw) for invalid actions -- caller decides how to handle
- keptDice array determines which dice stay: if keptDice[i] is true, keep state.dice[i]; otherwise use newDice
- advanceTurn wraps around player array: (currentPlayerIndex + 1) % players.length
- Round increments when all players have had their turn (track via scoring -- each player scores once per round)
  </implementation>
</feature>

<verification>
- `npm test -- --testPathPattern=state-machine` passes all tests
- Tests cover: initial state creation, player ready-up, rolling, scoring, turn advancement, game end, error cases
- State machine prevents all illegal transitions
- No type errors
</verification>

<success_criteria>
- state-machine.ts exports: createInitialState, applyAction, isValidAction, advanceTurn, checkGameEnd, GameAction type
- Tests cover all action types and error cases (10+ test cases)
- Pure functions with no side effects
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-engine/02-03-SUMMARY.md`
</output>
