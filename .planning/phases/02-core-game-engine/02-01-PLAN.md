---
phase: 02-core-game-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/types/game.ts
  - src/lib/game/crypto-rng.ts
  - package.json
  - src/messages/de.json
autonomous: true

must_haves:
  truths:
    - "GameRoom model exists in database schema with all required fields"
    - "Shared game types are available for import across client and server"
    - "3D rendering dependencies are installed and importable"
    - "Server-side cryptographic dice rolling function exists"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "GameRoom model with settings, state, players"
      contains: "model GameRoom"
    - path: "src/types/game.ts"
      provides: "All game type definitions"
      exports: ["GameRoom", "GameState", "KniffelScoresheet", "DiceValues", "GamePhase", "PlayerState"]
    - path: "src/lib/game/crypto-rng.ts"
      provides: "Cryptographic dice rolling"
      exports: ["rollDice"]
    - path: "package.json"
      provides: "3D dependencies installed"
      contains: "@react-three/fiber"
  key_links:
    - from: "src/types/game.ts"
      to: "prisma/schema.prisma"
      via: "Type definitions mirror Prisma model shape"
      pattern: "GameRoom|GamePhase"
---

<objective>
Create the foundational database schema, shared TypeScript types, cryptographic RNG utility, and install 3D rendering dependencies for Phase 2.

Purpose: Every subsequent plan depends on game types and the GameRoom model. Installing 3D deps early lets parallel plans (dice scene) start without waiting.
Output: Prisma schema with GameRoom model, comprehensive game type definitions, crypto dice roller, R3F + Rapier installed, Phase 2 German translations added.
</objective>

<execution_context>
@C:\Users\maxi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\maxi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-game-engine/02-RESEARCH.md
@prisma/schema.prisma
@src/types/index.ts
@package.json
@src/messages/de.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GameRoom model to Prisma schema and create game types</name>
  <files>
    prisma/schema.prisma
    src/types/game.ts
    src/lib/game/crypto-rng.ts
  </files>
  <action>
1. Add GameRoom model to prisma/schema.prisma:
```prisma
model GameRoom {
  id            String   @id @default(cuid())
  name          String
  hostId        String
  gameType      String   @default("kniffel")
  status        String   @default("waiting") // waiting, playing, ended
  isPrivate     Boolean  @default(false)
  maxPlayers    Int      @default(6)
  turnTimer     Int      @default(60) // seconds: 30, 60, 90
  afkThreshold  Int      @default(3) // consecutive inactive rounds
  gameState     Json?    // Stores full game state as JSON
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  host          User     @relation("HostedRooms", fields: [hostId], references: [id])
}
```
Add the relation to User model: `hostedRooms GameRoom[] @relation("HostedRooms")`

Run `npx prisma validate` to verify schema is correct. Do NOT run prisma db push (user may not have DB running).

2. Create src/types/game.ts with comprehensive type definitions:

```typescript
// Dice types
export type DiceValue = 1 | 2 | 3 | 4 | 5 | 6
export type DiceValues = [DiceValue, DiceValue, DiceValue, DiceValue, DiceValue]
export type KeptDice = boolean[] // which dice are kept (true = kept)

// Game phases - state machine states
export type GamePhase = 'waiting' | 'rolling' | 'scoring' | 'ended'

// Kniffel scoring categories
export type ScoreCategory =
  | 'ones' | 'twos' | 'threes' | 'fours' | 'fives' | 'sixes'  // upper
  | 'threeOfKind' | 'fourOfKind' | 'fullHouse'                   // lower
  | 'smallStraight' | 'largeStraight' | 'kniffel' | 'chance'     // lower

export interface KniffelScoresheet {
  ones?: number
  twos?: number
  threes?: number
  fours?: number
  fives?: number
  sixes?: number
  threeOfKind?: number
  fourOfKind?: number
  fullHouse?: number
  smallStraight?: number
  largeStraight?: number
  kniffel?: number
  chance?: number
}

// Player state within a game
export interface PlayerState {
  userId: string
  displayName: string
  scoresheet: KniffelScoresheet
  isReady: boolean
  isConnected: boolean
  lastActivity: number // timestamp
  consecutiveInactive: number
}

// Full game state (stored as JSON in GameRoom.gameState)
export interface GameState {
  phase: GamePhase
  players: PlayerState[]
  spectators: string[] // userIds
  currentPlayerIndex: number
  dice: DiceValues
  keptDice: KeptDice
  rollsRemaining: number // 0-3
  round: number // 1-13 (13 rounds in Kniffel)
  turnStartedAt: number | null // timestamp for timer sync
  turnDuration: number // seconds
  winner: string | null // userId
}

// Room settings (sent when creating a room)
export interface RoomSettings {
  name: string
  maxPlayers: number // 2-6
  isPrivate: boolean
  turnTimer: number // 30, 60, or 90
  afkThreshold: number // consecutive inactive rounds
}

// Room info for lobby display
export interface RoomInfo {
  id: string
  name: string
  hostId: string
  hostName: string
  gameType: string
  status: 'waiting' | 'playing' | 'ended'
  isPrivate: boolean
  maxPlayers: number
  currentPlayers: number
  playerNames: string[]
  createdAt: string
}

// Chat message
export interface ChatMessage {
  id: string
  roomId: string
  userId: string
  displayName: string
  content: string
  isSystem: boolean
  timestamp: number
}

// Socket event payloads
export interface RoomCreatedPayload {
  roomId: string
  room: RoomInfo
}

export interface GameStateUpdate {
  state: GameState
  roomId: string
}

// Vote rematch
export interface RematchVote {
  votedYes: string[]
  votedNo: string[]
  total: number
  required: number // majority
}
```

3. Create src/lib/game/crypto-rng.ts:
```typescript
import { randomInt } from 'node:crypto'
import type { DiceValue, DiceValues } from '@/types/game'

export function rollDice(count: number = 5): DiceValue[] {
  return Array.from({ length: count }, () => randomInt(1, 7) as DiceValue)
}

export function rollFiveDice(): DiceValues {
  return rollDice(5) as DiceValues
}
```
This file is SERVER-ONLY (uses node:crypto). Mark with a comment at the top: `// Server-only: uses node:crypto for CSPRNG (SPIEL-07)`
  </action>
  <verify>
Run `npx prisma validate` in project root - must pass without errors.
Run `npx tsc --noEmit` - TypeScript compilation must succeed (no type errors).
  </verify>
  <done>
GameRoom model in schema.prisma with all fields (name, hostId, gameType, status, isPrivate, maxPlayers, turnTimer, afkThreshold, gameState JSON).
Game types exported from src/types/game.ts covering all Phase 2 needs.
Crypto RNG utility exports rollDice and rollFiveDice functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Install 3D dependencies and add Phase 2 German translations</name>
  <files>
    package.json
    src/messages/de.json
  </files>
  <action>
1. Install 3D rendering dependencies:
```bash
npm install three @types/three @react-three/fiber @react-three/drei @react-three/rapier
```
Verify installation succeeds and packages appear in package.json dependencies.

2. Add Phase 2 German translations to src/messages/de.json. Add these sections alongside existing entries (do NOT remove existing keys):

```json
{
  "game": {
    "kniffel": "Kniffel",
    "roll": "Wuerfeln",
    "rollsRemaining": "{count} Wuerfe uebrig",
    "noRollsLeft": "Keine Wuerfe mehr",
    "keepDice": "Wuerfel behalten",
    "releaseDice": "Wuerfel freigeben",
    "yourTurn": "Du bist dran!",
    "waitingForPlayer": "{name} ist am Zug",
    "autoPlayWarning": "Auto-Zug in {seconds}s",
    "gameOver": "Spiel beendet",
    "winner": "Gewinner: {name}",
    "tie": "Unentschieden!",
    "round": "Runde {current} von {total}",
    "skipAnimation": "Animation ueberspringen",
    "spectating": "Du schaust zu"
  },
  "room": {
    "create": "Raum erstellen",
    "join": "Beitreten",
    "leave": "Verlassen",
    "roomName": "Raumname",
    "maxPlayers": "Max. Spieler",
    "turnTimer": "Zugzeit",
    "turnTimerSeconds": "{seconds}s",
    "afkThreshold": "AFK-Schwelle (Runden)",
    "private": "Privat",
    "public": "Oeffentlich",
    "waiting": "Wartet",
    "playing": "Laeuft",
    "ended": "Beendet",
    "players": "{count}/{max} Spieler",
    "ready": "Bereit",
    "notReady": "Nicht bereit",
    "startGame": "Spiel starten",
    "forceStart": "Spiel erzwingen",
    "kickPlayer": "Spieler entfernen",
    "hostControls": "Gastgeber-Optionen",
    "roomFull": "Raum ist voll",
    "gameInProgress": "Spiel laeuft bereits",
    "noRooms": "Keine offenen Raeume",
    "createFirst": "Erstelle einen Raum und lade Freunde ein!"
  },
  "scoresheet": {
    "ones": "Einser",
    "twos": "Zweier",
    "threes": "Dreier",
    "fours": "Vierer",
    "fives": "Fuenfer",
    "sixes": "Sechser",
    "upperBonus": "Bonus (ab 63)",
    "upperTotal": "Oberer Teil",
    "threeOfKind": "Dreierpasch",
    "fourOfKind": "Viererpasch",
    "fullHouse": "Full House",
    "smallStraight": "Kleine Strasse",
    "largeStraight": "Grosse Strasse",
    "kniffel": "Kniffel",
    "chance": "Chance",
    "lowerTotal": "Unterer Teil",
    "grandTotal": "Gesamtpunktzahl",
    "compact": "Kompakt",
    "fullTable": "Alle Spieler"
  },
  "chat": {
    "title": "Chat",
    "placeholder": "Nachricht schreiben...",
    "send": "Senden",
    "systemJoined": "{name} ist beigetreten",
    "systemLeft": "{name} hat den Raum verlassen",
    "systemRolled": "{name} hat gewuerfelt",
    "systemScored": "{name} hat {category} gewaehlt",
    "systemKniffel": "{name} hat Kniffel gewuerfelt!",
    "systemKicked": "{name} wurde entfernt (AFK)",
    "systemGameStarted": "Das Spiel beginnt!",
    "systemGameEnded": "Spiel beendet! Gewinner: {name}"
  },
  "rematch": {
    "title": "Noch eine Runde?",
    "voteYes": "Ja, nochmal!",
    "voteNo": "Nein, danke",
    "waiting": "Warte auf Abstimmung... ({yes}/{total})",
    "accepted": "Rematch! Neues Spiel startet...",
    "declined": "Kein Rematch. Zurueck zur Lobby."
  }
}
```

Note: Use ae/oe/ue instead of umlauts in translation values to avoid encoding issues. The UI will render these correctly.

Actually, use proper German umlauts (ä, ö, ü, ß) since the file is UTF-8 JSON. Correct the translations to use proper umlauts:
- "Würfeln", "Würfe übrig", "Würfel behalten", "Würfel freigeben", etc.
- "Öffentlich", "Räume", "Straße", "Größe", etc.

3. Verify the build still passes: `npm run build`
  </action>
  <verify>
Run `npm ls three @react-three/fiber @react-three/drei @react-three/rapier` - all packages listed.
Run `npm run build` - build succeeds without errors.
Verify de.json is valid JSON (no syntax errors).
  </verify>
  <done>
three, @react-three/fiber, @react-three/drei, @react-three/rapier in package.json dependencies.
de.json contains game, room, scoresheet, chat, and rematch translation sections with proper German umlauts.
Build passes successfully.
  </done>
</task>

</tasks>

<verification>
- `npx prisma validate` passes
- `npx tsc --noEmit` passes
- `npm run build` passes
- GameRoom model exists in schema
- All game types importable from @/types/game
- 3D packages installed
- German translations complete for Phase 2
</verification>

<success_criteria>
- Prisma schema has GameRoom model with JSON gameState field
- src/types/game.ts exports all game-related types
- src/lib/game/crypto-rng.ts exports rollDice with crypto.randomInt
- R3F + Rapier packages installed
- de.json has translations for game, room, scoresheet, chat, rematch
- Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-engine/02-01-SUMMARY.md`
</output>
